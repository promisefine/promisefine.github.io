{"meta":{"title":"Doney","subtitle":"卷野の博客","description":"专科 | 计算机科学与技术 | 网络安全","author":"Doney","url":"https://promisefine.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-12T00:45:59.560Z","updated":"2021-07-12T00:45:59.560Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://promisefine.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.354Z","comments":true,"path":"404.html","permalink":"https://promisefine.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-07-12T00:45:59.563Z","updated":"2021-07-12T00:45:59.563Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://promisefine.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.558Z","comments":true,"path":"about/index.html","permalink":"https://promisefine.github.io/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.389Z","comments":true,"path":"List/index.html","permalink":"https://promisefine.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.559Z","comments":true,"path":"archives/index.html","permalink":"https://promisefine.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-07-12T00:45:59.561Z","comments":true,"path":"census/index.html","permalink":"https://promisefine.github.io/census/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.560Z","comments":true,"path":"categories/index.html","permalink":"https://promisefine.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-14T06:09:43.269Z","comments":true,"path":"contact/index.html","permalink":"https://promisefine.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.564Z","comments":true,"path":"resource/index.html","permalink":"https://promisefine.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.566Z","comments":true,"path":"tags/index.html","permalink":"https://promisefine.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/index.html","permalink":"https://promisefine.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.390Z","comments":true,"path":"List/movies/index.html","permalink":"https://promisefine.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.391Z","comments":true,"path":"List/music/index.html","permalink":"https://promisefine.github.io/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://promisefine.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.392Z","comments":true,"path":"List/tools/index.html","permalink":"https://promisefine.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://promisefine.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-07-12T00:45:59.379Z","updated":"2021-07-12T00:45:59.379Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-07-12T00:45:59.380Z","updated":"2021-07-12T00:45:59.380Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://promisefine.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-07-12T00:45:59.382Z","updated":"2021-07-12T00:45:59.382Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-07-12T00:45:59.384Z","updated":"2021-07-12T00:45:59.384Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-07-12T00:45:59.386Z","updated":"2021-07-12T00:45:59.386Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-07-12T00:45:59.387Z","updated":"2021-07-12T00:45:59.387Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://promisefine.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"算法","slug":"algorithm","date":"2019-11-29T02:01:45.000Z","updated":"2021-07-15T11:48:33.858Z","comments":true,"path":"posts/9505ccb9.html","link":"","permalink":"https://promisefine.github.io/posts/9505ccb9.html","excerpt":"","text":"复杂度// 大O算法就是算法执⾏所需要的执⾏次数，和数据量的关系(时间复杂度),占⽤额外空间和数据量的关系(空间复杂度) O(1) : 常数复杂度 (和数据量⽆关) O(logn) :对数复杂度 (⼆分) O(n) : 线性时间复杂度 （数组遍历⼀次） O(n*logn) : 线性对数 （遍历+⼆分） O(n^2) : 平⽅ 两层遍历 O(2^n) : 指数 递归 O(n!) : 阶乘 冒泡排序function bubleSort(arr) { var len = arr.length for (let outer = len; outer &gt;= 2; outer--) { for (let inner = 0; inner &lt;= outer - 1; inner++) { if (arr[inner] &gt; arr[inner + 1]) { [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]] } } } return arr } console.log(bubleSort([4, 3, 6, 1, 9, 6, 2])) 插入排序function insertSort(arr) { for (let i = 1; i &lt; arr.length; i++) { //外循环从1开始，默认arr[0]是有序段 for (let j = i; j &gt; 0; j--) { //j = i,将arr[j]依次插⼊有序段中 if (arr[j] &lt; arr[j - 1]) { [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; } else { break; } } } return arr; } console.log(insertSort([11, 4, 3, 6, 1, 9, 7, 2, 0])) 快速排序function quickSort(arr) { if (arr.length &lt;= 1) { return arr; //递归出⼝ } var left = [], right = [], current = arr.splice(0, 1); //注意splice后，数组⻓度少了⼀个 for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; current) { left.push(arr[i]) //放在左边 } else { right.push(arr[i]) //放在右边 } } return quickSort(left).concat(current, quickSort(right)); //递归 } 数组扁平化Array.prototype.flat = function () { var arr = []; this.forEach((item, idx) =&gt; { if (Array.isArray(item)) { arr = arr.concat(item.flat()); //递归去处理数组元素 } else { arr.push(item) //⾮数组直接push进去 } }) return arr; //递归出⼝ } arr = [1, 2, 3, [4, 5, [6, 7, [8, 9]]], [10, 11] ] console.log(arr.flat()) 查找算法// 循环的二分查找 function binarySearch(arr, target) { var low = 0, high = arr.length - 1, mid; while (low &lt;= high) { mid = Math.floor((low + high) / 2); if (target === arr[mid]) { return `找到了${target},在第${mid + 1}个` } if (target &gt; arr[mid]) { low = mid + 1; } else if (target &lt; arr[mid]) { high = mid - 1; } } return -1 } console.log(binarySearch([1, 2, 3, 4, 5, 7, 9, 11, 14, 16, 17, 22, 33, 55, 65], 4)) // 递归的二分查找 function binarySearch1(arr, target, low = 0, high = arr.length - 1) { const n = Math.floor((low + high) / 2); const cur = arr[n]; if (cur === target) { return `找到了${target},在第${n+1}个`; } else if (cur &gt; target) { return binarySearch1(arr, target, low, n - 1); } else if (cur &lt; target) { return binarySearch1(arr, target, n + 1, high); } return -1; } 数据结构栈class Stack { constructor() { this.items = [] } push(item) { this.items.push(item) } pop() { return this.items.pop() } size() { return this.items.length } clear() { this.items = [] } } 索引: O(n) 搜索: O(n) 插⼊: O(1) 移除: O(1) // 经典案例： 括号匹配，html标签匹配，进制转换 function isBalance(symbol) { const stack = new Stack() const left = '{(' const right = '})' let popValue let tag = true const match = function (popValue, current) { if (left.indexOf(popValue) !== right.indexOf(current)) { tag = false } } for (let i = 0; i &lt; symbol.length; i++) { if (left.includes(symbol[i])) { stack.push(symbol[i]) } else if (right.includes(symbol[i])) { popValue = stack.pop() match(popValue, symbol[i]) } } return tag } console.log(isBalance('{{(({}))}}')) console.log(isBalance('{{(({})}}')) 链表 class Node { constructor(element) { this.element = element this.next = null } } class LinkedList { constructor() { this.head = null this.current this.length = 0 } append(element) { const node = new Node(element) if (this.head === null) { // 插⼊第⼀个链表 this.head = node } else { this.current = this.head while (this.current.next) { // 找到最后⼀个节点 this.current = this.current.next } this.current.next = node } this.length++ } // 移除指定位置元素 removeAt(position) { if (position &gt; -1 &amp;&amp; position &lt; this.length) { let previous let index = 0 if (position === 0) { // 如果是第⼀个链表的话, 特殊对待 this.head = this.head.next } else { 开课吧web全栈架构师 this.current = this.head while (index &lt; position) { // 循环找到当前要删除元素的位置 previous = this.current this.current = this.current.next index++ } previous.next = this.current.next } this.length-- } } // 在指定位置加⼊元素 insert(position, element) { const node = new Node(element) let index = 0 let current, previous if (position &gt; -1 &amp;&amp; position &lt; this.length + 1) { if (position === 0) { // 在链表最前插⼊元素 current = this.head this.head = node this.head.next = current } else { current = this.head while (index &lt; position) { // 同 removeAt 逻辑, 找到⽬标位置 previous = current current = current.next index++ } previous.next = node // 在⽬标位置插⼊相应元素 node.next = current } this.length++ } } // 链表中是否含有某个元素, 如果有的话返回相应位置, ⽆的话返回 -1 indexOf(element) { let index = 0 this.current = this.head while (index &lt; this.length) { if (this.current.element === element) { return index } this.current = this.current.next index++ } return -1 } // 移除某元素 remove(element) { const position = this.indexOf(element) this.removeAt(position) } // 获取⼤⼩ size() { return this.length } // 获取最开头的链表 getHead() { return this.head } // 是否为空 isEmpty() { return this.length === 0 } // 打印链表元素 log() { this.current = this.head let str = this.current.element while (this.current.next) { this.current = this.current.next str = str + ' ' + this.current.element } console.log(str) return str } } // 测试⽤例 var linkedList = new LinkedList() linkedList.append(5) linkedList.append(10) linkedList.append(15) linkedList.append(20) linkedList.log() // '5 10 15 20' linkedList.removeAt(1) linkedList.log() // '5 15 20' linkedList.insert(1, 10) linkedList.log() 集合 Set和Mapnew Set() new WeekSet() new Map() new WeekMap() class Set { constructor() { this.items = {} } has(value) { return this.items.hasOwnProperty(value) } add(value) { if (!this.has(value)) { this.items[value] = value return true } return false } remove(value) { if (this.has(value)) { delete this.items[value] return true } return false } get size() { return Object.keys(this.items).length } get values() { return Object.keys(this.items) } } const set = new Set() set.add(1) console.log(set.values) // [\"1\"] console.log(set.has(1)) // true console.log(set.size) // 1 set.add(2) console.log(set.values) // [\"1\", \"2\"] console.log(set.has(2)) // true console.log(set.size) // 2 set.remove(1) console.log(set.values) // [\"2\"] set.remove(2) console.log(set.values) // [] 哈希表 名称 散列函数 散列值 散列表 John 74+111+104+110 399 [399] [john@qq.com] class HashTable { constructor() { this.items = {} } put(key, value) { const hash = this.keyToHash(key) this.items[hash] = value } get(key) { return this.items[this.keyToHash(key)] } remove(key) { delete(this.items[this.keyToHash(key)]) } keyToHash(key) { let hash = 0 for (let i = 0; i &lt; key.length; i++) { hash += key.charCodeAt(i) } hash = hash % 37 // 为了避免 hash 的值过⼤ return hash } } let ht = new HashTable() ht.put('name', 'xxx') ht.put('age', '6') console.log(ht.get('name')) ht.remove('name') console.log(ht.get('name')) 算法技巧动态规划// 例如斐波那契 // 递归 function fib(n) { if (n == 1 || n == 2) return 1 return fib(n - 1) + fib(n - 2) } // 动归 解决子问题重复 function fib(n) { let memo = [] return helper(memo, n) } function helper(memo, n) { if (n == 1 || n == 2) { // 前两个 return 1 } // 如果有缓存，直接返回 if (memo[n]) return memo[n]; // 没缓存 memo[n] = helper(memo, n - 1) + helper(memo, n - 2) return memo[n] } // 动归解决 function fib(n) { let dp = [] dp[1] = dp[2] = 1 for (let i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n] } // 假如有1,5,10,20,50,100人民币 4 [1, 1, 1, 1] // 需 4 个 1 5 [5] // 需 1 个 5 36 [20, 10, 5, 1] // 需 20、10、5、1各⼀个 class Change { constructor(changeType) { this.changeType = changeType this.cache = {} } makeChange(amount) { let min = [] if (!amount) { return [] } if (this.cache[amount]) { // 读缓存 return this.cache[amount] } for (let i = 0; i &lt; this.changeType.length; i++) { const leftAmount = amount - this.changeType[i] let newMin if (leftAmount &gt;= 0) { newMin = this.makeChange(leftAmount) // 这⼀句是动态规划的提现 } if (leftAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length - 1 || !min.length)) { // 如果存在更⼩的找零硬币数, 则执⾏后⾯语句 min = [this.changeType[i]].concat(newMin) } } return this.cache[amount] = min } } const change = new Change([1, 5, 10, 20, 50, 100]) console.log(change.makeChange(2)) console.log(change.makeChange(5)) console.log(change.makeChange(13)) console.log(change.makeChange(35)) console.log(change.makeChange(135)) 贪心算法 // 贪⼼ 先找最大面值，超了再找其他的 class Change { constructor(changeType) { this.changeType = changeType.sort((r1, r2) =&gt; r2 - r1) } makeChange(amount) { const arr = [] for (let i = 0; i &lt; this.changeType.length; i++) { while (amount - this.changeType[i] &gt;= 0) { arr.push(this.changeType[i]) amount = amount - this.changeType[i] } } return arr } } const change = new Change([1, 5, 10, 20, 50, 100]) console.log(change.makeChange(36)) console.log(change.makeChange(136)) console.log('-'.repeat(100)) // 有时贪心算法不一定准确，求的最大近似解 const change1 = new Change([1, 3, 4]) console.log(change1.makeChange(6)) // 其实[3, 3]最好","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"前端性能优化","slug":"optimization","date":"2019-11-16T00:10:03.000Z","updated":"2021-07-16T00:22:26.797Z","comments":true,"path":"posts/604c45ad.html","link":"","permalink":"https://promisefine.github.io/posts/604c45ad.html","excerpt":"","text":"前端性能优化：从输入URL到页面加载完成，发生了什么 1. ⽤户输⼊www.baidu.com 2. 浏览器通过DNS，把url解析为IP 3. 和IP地址建⽴TCP链接 发送HTTP请求 4. 服务器接收请求，查库，读⽂件等，拼接好返回的HTTP响应 5. 浏览器收到⾸屏html，开始渲染 6. 解析html为dom 7. 解析css 为css-tree 8. dom+ css ⽣成render-tree 绘图 9. 加载script的js⽂件 10. 执⾏js // DNS 优化 &lt;link rel=\"dns-prefetch\" href=\"dns的地址\"/&gt; // IP TCP HTTP的关系 1、IP负责找到资源 2、TCP负责数据的完整性和有序性，三次握手四次挥手 3、http应用层，负责应用层数据 // 优化 1. ⻓连接 2. 减少⽂件体积 1. js打包压缩 2. 图⽚压缩 3. gzip 3. 减少⽂件请求次数 1. 雪碧图 2. js，css打包 3. 缓存控制 4. 懒加载 4. 减少⽤户和服务器的距离 1. cdn 5. 本地存储 6. http优化 将验证放在header中 // 通过⽹络获取内容既速度缓慢⼜开销巨⼤。较⼤的响应需要在客户端与服务器之间进⾏多次往返通信， // 这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费⽤。因此，缓存并重复利⽤之前获取 // 的资源的能⼒成为性能优化的⼀个关键⽅⾯。 7、浏览器缓存 1. Http Cache 2. Service Worker Cache 独立于主线程之外的js,实现离线缓存和网络代理 window.navigator.serviceWorker.register('/xxx.js').then( function () { console.log('注册成功') }).catch(err =&gt; { console.error(\"注册失败\") }) 3. Memory Cache 4. Push Cache // header中设置 强缓存 expires: Wed, 11 Mar 2019 16:12:18 GMT cache-control: max-age=31536000 // 1.1 精准 优先级⾼ // 协商缓存 304 not Modified 1、第一种方式 If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT 2、第二种方式 ETag: W/\"2aaa-129892f459\" // 类似文件的指纹 If-None-Match: W/\"2aaa-129892f459\" 文件打包 webpack图片优化// performance performance.getEntriesByType('navigation') // lighthouse npm install -g lighthouse lighthouse https://www.kaikeba.com/ --view // 以上两个用于性能监控 图⽚通常是最占⽤流量的，PC端加载的平均图⽚⼤⼩时600K. 不同的场景，使⽤不同的⽂件⾥类型 1. jpg 1. 有损压缩 2. 体积⼩ 不⽀持透明 3. ⽤于背景图，轮播图 2. png 1. ⽆损压缩，质量⾼，⽀持透明 2. ⾊彩线条更丰富，⼩图，⽐如logo，商品icon 3. svg 1. ⽂本，体积⼩ ⽮量图 2. 渲染成本，学习成本 gzip accept-encoding:gzip 开启gzipHTTP 压缩就是以缩⼩体积为⽬的，对 HTTP 内容进⾏重新编码的过程 Gzip 压缩背后的原理，是在⼀个⽂本⽂件中找出⼀些重复出现的字符串、临时替换它们，从⽽使整个⽂ 件变⼩。根据这个原理，⽂件中代码的重复率越⾼，那么压缩的效率就越⾼，使⽤ Gzip 的收益也就越 ⼤。 基本上来说，Gzip都是服务器⼲的活，⽐如nginx 服务器端渲染 React的Nextjs Vue的NuxtjsReact的长列表加载 React-virtualizedimport { List } from \"react-virtualized\"; &lt;div className=\"list\"&gt; &lt;List width={rowWidth} height={listHeight} rowHeight={rowHeight} rowRenderer={this.renderRow.bind(this)} rowCount={this.list.length} /&gt; &lt;/div&gt; renderRow({ index, key, style }) { return ( &lt;div key={key} style={style} className=\"row\"&gt; &lt;div className=\"image\"&gt; &lt;img src={this.list[index].image} alt=\"\" /&gt; &lt;/div&gt; &lt;div className=\"content\"&gt; &lt;div&gt;{this.list[index].name}&lt;/div&gt; &lt;div&gt;{this.list[index].text}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } 白屏应对⻣架，⾃动化⽅案，page-skeleton-webpack-plugin, 以及antd的skeleton组件 移动端点击事件300s的延迟和点击穿透// 移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动。这些行为，尤其是双击缩放，主要是为桌面网站在移动端的浏览体验设计的。而在用户对页面进行操作的时候，移动端浏览器会优先判断用户是否要触发默认的行为。 1、方案一：禁用缩放 &lt;meta name=\"viewport\" content=\"user-scalable=no\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\"&gt; 2、方案二：更改默认的视口宽度 &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; 方案一、二 Chrome支持 3、CSS touch-action: none IE支持 主要解决方案: // 使用FastClick库 // FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。 // 点击穿透 说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？ 使用touchstart去代替click事件有两个不好的地方。 第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果； 第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。 // 什么是点击穿透？ 假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。 这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://promisefine.github.io/tags/Web/"}],"author":"Doney"},{"title":"Http的缓存机制","slug":"cache","date":"2019-10-20T00:20:18.000Z","updated":"2021-07-16T00:25:56.901Z","comments":true,"path":"posts/41476be7.html","link":"","permalink":"https://promisefine.github.io/posts/41476be7.html","excerpt":"","text":"Http的缓存机制function updatetime() { this.timer = this.timer || setInterval(() =&gt; this.time = Date.now(), 5000) return this.time } const http = require('http') http.createServer((req, res) =&gt; { const { url } = req if ('/' === url) { res.end(` &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; 更新时间 | ${updatetime()} &lt;script src=\"/main.js\"&gt;&lt;/script&gt; &lt;/html&gt; `) } else if (url === '/main.js') { const content = `document.write('&lt;br&gt;main | ${updatetime()}')` // 强缓存 expire // res.setHeader('Expires',new Date(Date.now()+10*1000).toGMTString()) // res.setHeader('Cache-Control','max-age=10') res.setHeader('Cache-Control', 'no-cache') // 设置过期时间 // res.setHeader('last-modified',new Date().toGMTString()) // if(new Date(req.headers['if-modified-since']).getTime() + 8*60*3600*1000 + 3 &gt; Date.now()){ // console.log(\"协商缓存命中\"); // res.statusCode = 304 // res.end('') // return // } // 另一种协商缓存 hash const crypto = require('crypto') const hash = crypto.createHash('sha1').update(content).digest('hex') console.log(hash, \"----\"); console.log(req.headers, \"+++++++\"); res.setHeader('Etag', hash) if (req.headers['if-none-match'] === hash) { console.log(\"协商缓存命中\"); res.statusCode = 304 res.end('') return } res.statusCode = 200 res.end(content) } else if (url === '/favicon.ico') { res.end('') } }) .listen(3000, () =&gt; { console.log('服务器运行在3000端口'); }) 异步读取文件const fs = require('fs') const {promisify} = require('util') const readFile = promisify(fs.readFile) process.nextTick(async () =&gt; { const data = await readFile('./index.html') // console.log(data.toString()); const buf = Buffer.alloc(10) console.log(data); }) 流 node基于流const fs = require('fs') const rs = fs.createReadStream('./index.html') const ws = fs.createWriteStream('./home.html') rs.pipe(ws) 制定auto-vue-routernpm i commander download-git-repo ora handlebars figlet clear chalk open -s // bin/yl.js #!/usr/bin/env node const program = require('commander') program.version(require('../package').version) program .command('init &lt;name&gt;') .description('init project') // .action(name =&gt; { // console.log('init ' + name) // }) .action(require('../lib/init')) program .command('refresh') .description('refresh routers...') .action(require('../lib/refresh')) program.parse(process.argv) // lib/init.js // 将异步变成同步 const { promisify } = require('util') // 输出一些特殊的文字 为异步方法 const figlet = promisify(require('figlet')) const clear = require('clear') // 改变命令行风格 --- 颜色等 const chalk = require('chalk') const log = content =&gt; console.log(chalk.green(content)) // clone克隆 const {clone} = require('./download') // 安装依赖 const spawn = async (...args) =&gt; { // 开启子进程 const { spawn } = require('child_process'); return new Promise(resolve =&gt; { const proc = spawn(...args) // 输出流 子进程导入到主进程 proc.stdout.pipe(process.stdout) // 错误流 proc.stderr.pipe(process.stderr) proc.on('close', () =&gt; { resolve() }) }) } // 打开浏览器 const open = require(\"open\") module.exports = async name =&gt; { console.log(name, \"|| name\"); // 打印欢迎画⾯ clear() const data = await figlet('yl Welcome') log(data); log('🚀创建项⽬:' + name) // 克隆项目 await clone('github:su37josephxia/vue-template', name) // 安装依赖 log('安装依赖'); // cnpm install ./test await spawn('cnpm', ['install'], { cwd: `./${name}` }) log(chalk.green(` To get Start: =========================== cd ${name} npm run serve =========================== `)) // 打开浏览器 open(`http://localhost:8080`); await spawn('npm', ['run', 'serve'], { cwd: `./${name}` }) } // lib/download.js const { promisify } = require('util') module.exports.clone = async function (repo, desc) { const download = promisify(require('download-git-repo')) const ora = require('ora') const process = ora(`下载.....${repo}`) process.start() await download(repo, desc) process.succeed() } // lib/refresh.js const fs = require('fs') const handlebars = require('handlebars') const chalk = require('chalk') module.exports = async () =&gt; { // 获取⻚⾯列表 const list = fs.readdirSync('./src/views') .filter(v =&gt; v !== 'Home.vue') .map(v =&gt; ({ name: v.replace('.vue', '').toLowerCase(), file: v })) // ⽣成路由定义 compile({ list }, './src/router.js', './template/router.js.hbs') // ⽣成菜单 compile({ list }, './src/App.vue', './template/App.vue.hbs') /** * 编译模板⽂件 * @param meta 数据定义 * @param filePath ⽬标⽂件路径 * @param templatePath 模板⽂件路径 */ function compile(meta, filePath, templatePath) { if (fs.existsSync(templatePath)) { const content = fs.readFileSync(templatePath).toString(); const result = handlebars.compile(content)(meta); fs.writeFileSync(filePath, result); } console.log(chalk.green(`🚀${filePath} 创建成功`)) } } AOP：Aspect Oriented Programming 面向切面编程日志记录，性能统计，安全控制，事务处理，异常处理等等。Koaconst Koa = require('koa') const app = new Koa() app.use(require('koa-static')(__dirname + '../public/')) const router = require('koa-router')() router.get('/string', async (ctx, next) =&gt; { ctx.body = 'koa2 string' }) router.get('/json', async (ctx, next) =&gt; { ctx.body = { title: 'koa2 json' } }) app.use(router.routes()) app.use(async (ctx, next) =&gt; { const start = new Date().getTime() console.log(`start: ${ctx.url}`); await next() const end = new Date().getTime() console.log(`${ctx.url} | 耗时: ${end - start}ms`); }) app.use((ctx) =&gt; { ctx.body = 'Hello Koa' }) app.listen(3000) 组合函数 compose函数Koa中间件机制就是函数式 组合概念 Compose的概念，将⼀组需要顺序执⾏的函数复合为⼀个函数，外层函数的参数实际是内层函数的返回值。const add = (x, y) =&gt; x + y const square = z =&gt; z * z const fn = (x, y) =&gt; square(add(x, y)) console.log(fn(1, 2)) const compose = (fn1, fn2) =&gt; (...args) =&gt; fn2(fn1(...args)) const fn = compose(add,square) const compose = (...[first, ...other]) =&gt; (...args) =&gt; { let ret = first(...args) other.forEach(fn =&gt; { ret = fn(ret) }) return ret } const fn = compose(add, square) console.log(fn(1, 2)) function compose(middlewares) { return function () { return dispatch(0); // 执⾏第0个 function dispatch(i) { let fn = middlewares[i]; if (!fn) { return Promise.resolve(); } return Promise.resolve( fn(function next() { // promise完成后，再执⾏下⼀个 return dispatch(i + 1); }) ); } }; } async function fn1(next) { console.log(\"fn1\"); await next(); console.log(\"end fn1\"); } async function fn2(next) { console.log(\"fn2\"); await delay(); await next(); console.log(\"end fn2\"); } function fn4(next) { console.log(\"fn4\"); next() } async function fn3(next) { console.log(\"fn3\"); await delay(); await next(); console.log(\"end fn3\"); } function delay() { return new Promise((reslove) =&gt; { setTimeout(() =&gt; { reslove(); }, 2000); }); } const middlewares = [fn1, fn2, fn4, fn3]; const finalFn = compose(middlewares); finalFn();","categories":[],"tags":[{"name":"Http","slug":"Http","permalink":"https://promisefine.github.io/tags/Http/"}],"author":"Doney"},{"title":"设计模式","slug":"Design","date":"2019-10-08T06:22:10.000Z","updated":"2021-07-15T11:48:48.707Z","comments":true,"path":"posts/364ea8cc.html","link":"","permalink":"https://promisefine.github.io/posts/364ea8cc.html","excerpt":"","text":"设计模式（Design Pattern）是⼀套被反复使⽤、多数⼈知晓的、经过分类的、代码设计经验的总结。发布订阅模式class Event { constructor() { this.callbacks = {} } $off(name) { this.callbacks[name] = null } $emit(name, args) { let cbs = this.callbacks[name] if (cbs) { cbs.forEach(c =&gt; { c.call(this, args) }) } } $on(name, fn) { (this.callbacks[name] || (this.callbacks[name] = [])).push(fn) } } let event = new Event() event.$on('event1', function (arg) { console.log('事件1', arg) }) event.$on('event1', function (arg) { console.log('⼜⼀个时间1', arg) }) event.$on('event2', function (arg) { console.log('事件2', arg) }) event.$emit('event1', { name: '2005A' }) event.$emit('event2', { name: '2006A' }) event.$off('event1') event.$emit('event1', { name: '2007A' }) 单例模式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;单例模式&lt;/title&gt; &lt;style&gt; .model { border: 1px solid black; position: fixed; width: 300px; height: 300px; top: 20%; left: 50%; margin-left: -150px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;弹窗，⽆论点击多少次，弹窗只应该被创建⼀次&lt;/h1&gt; &lt;div id=\"loginBtn\"&gt;点我&lt;/div&gt; &lt;script&gt; var getSingle = function (fn) { var result; return function () { return result || (result = fn.apply(this, arguments)); } }; var createLoginLayer = function () { var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.className = 'model' div.style.display = 'none'; document.body.appendChild(div); return div; }; // 单例模式 可以去掉一下这一行代码试试页面点击情况 var createSingleLoginLayer = getSingle(createLoginLayer); document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 策略模式⼀个基于策略模式的程序⾄少由两部分组成。 // 第⼀个部分是⼀组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。 // 第⼆个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某⼀个策略类。 // 例子： var calc = function (pm, salary) { if (pm === 'S') { return salary * 4; } if (pm === 'A') { return salary * 3; } if (pm === 'B') { return salary * 2; } }; calculateBonus('B', 20000); // 输出:40000 calculateBonus('S', 6000); // 输出:24000 // 使用策略模式 var strategies = { \"S\": function (salary) { return salary * 4; }, \"A\": function (salary) { return salary * 3; }, \"B\": function (salary) { return salary * 2; } }; var calculateBonus = function (level, salary) { return strategies[level](salary); }; console.log(calculateBonus('S', 20000)); // 输出:80000 console.log(calculateBonus('A', 10000)); // 输出:30000 // 表单校验 var registerForm = document.getElementById('registerForm'); registerForm.onsubmit = function () { if (registerForm.userName.value === '') { alert('⽤户名不能为空'); return false; } if (registerForm.password.value.length &lt; 6) { alert('密码⻓度不能少于 6 位'); return false; } if (!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) { alert('⼿机号码格式不正确'); return false; } } // 使用策略模式 var strategies = { isNonEmpty: function (value, errorMsg) { if (value === '') { return errorMsg; } }, minLength: function (value, length, errorMsg) { if (value.length &lt; length) { return errorMsg; } }, isMobile: function (value, errorMsg) { // ⼿机号码格式 if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) { return errorMsg; } } }; var Validator = function () { this.cache = []; // 保存校验规则 }; Validator.prototype.add = function (){ var ary = rule.split(':'); this.cache.push(function () { // var strategy = ary.shift(); ary.unshift(dom.value); ary.push(errorMsg); return strategies[strategy].apply(dom, ary); }); }; Validator.prototype.start = function () { for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) { var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) { // 如果有确切的返回值，说明校验没有通过 return msg; } } }; var validataFunc = function () { var validator = new Validator(); // 创建⼀个 validator 对象 /***************添加⼀些校验规则****************/ validator.add(registerForm.userName, 'isNonEmpty', '⽤户名不能为空'); validator.add(registerForm.password, 'minLength:6', '密码⻓度不能少于 6位'); validator.add(registerForm.phoneNumber, 'isMobile', '⼿机号码格式不正确'); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果 } var registerForm = document.getElementById('registerForm'); registerForm.onsubmit = function () { var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if (errorMsg) { alert(errorMsg); return false; // 阻⽌表单提交 } }; 代理模式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .model { border: 1px solid black; position: fixed; width: 300px; height: 300px; top: 20%; left: 50%; margin-left: -150px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"checkbox\" id=\"1\"&gt; &lt;input type=\"checkbox\" id=\"2\"&gt; &lt;input type=\"checkbox\" id=\"3\"&gt; &lt;script&gt; var synchronousFile = function (id) { console.log('开始同步⽂件，id 为: ' + id); }; var proxySynchronousFile = (function () { var cache = [], // 保存⼀段时间内需要同步的 ID timer; // 定时器 return function (id) { cache.push(id); if (timer) { // 保证不会覆盖已经启动的定时器 return; } timer = setTimeout(function () { synchronousFile(cache.join(',')); clearTimeout(timer); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 }, 2000); } // 2 秒后向本体发送需要同步的 ID 集合 })(); var checkbox = document.getElementsByTagName('input'); for (var i = 0, c; c = checkbox[i++];) { c.onclick = function () { if (this.checked === true) { proxySynchronousFile(this.id); } } }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 工厂模式装饰器模式享元模式(优化模式，常用在封装弹框组件)export default { install(Vue) { // 在使⽤插件Vue.use(Message)时实例化⼀个Dialog组件对象 const Dialog = new Vue({ data() { return { icon: '', fontStyle: '', backgroundStyle: '', text: '' } } ... }) // 扩展Vue的`prototype` Vue.prototype.$Message = { success(text) { // 改变Dialog的data.xx的值触发Dialog的更新 Dialog.icon = successIcon Dialog.fontStyle = successFontStyle Dialog.backgroundStyle = successBackgroundStyle Dialog.text = text // 获取Dialog的最新DOM添加到body标签中 document.body.appendChild(Dialog.$el) }, warning(text) { // 同上 ... document.body.appendChild(Dialog.$el) }, error(text) { // 同上 ... document.body.appendChild(Dialog.$el) } } } }","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}]},{"title":"Promise并发","slug":"Concurrent","date":"2019-09-24T00:38:23.000Z","updated":"2021-07-16T00:39:59.211Z","comments":true,"path":"posts/9123c35c.html","link":"","permalink":"https://promisefine.github.io/posts/9123c35c.html","excerpt":"","text":"代码演示var urls = [ \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png\", ]; function loadImg(url) { return new Promise((resolve, reject) =&gt; { const img = new Image(); img.onload = function() { console.log(\"一张图片加载完成\"); resolve(img); }; img.onerror = function() { reject(new Error('地址加载失败:' + url)); }; img.src = url; }); }; function limitImageLoad(urls, handler, limit) { let sequence = [].concat(urls); // 复制urls // 这一步是为了初始化 promises 这个\"容器\" let promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { // 返回下标是为了知道数组中是哪一项最先完成 return index; }); }); // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用 return sequence .reduce((pCollect, url) =&gt; { return pCollect .then(() =&gt; { return Promise.race(promises); // 返回已经完成的下标 }) .then((fastestIndex) =&gt; { // 获取到已经完成的下标 // 将\"容器\"内已经完成的那一项替换 promises[fastestIndex] = handler(url).then(() =&gt; { return fastestIndex; // 要继续将这个下标返回，以便下一次变量 }); }) .catch((err) =&gt; { console.error(err); }); }, Promise.resolve()) // 初始化传入 .then(() =&gt; { // 最后三个用.all来调用 return Promise.all(promises); }); } // 代码调用 limitImageLoad(urls, loadImg, 3) .then((res) =&gt; { console.log(\"图片全部加载完毕\"); console.log(res); }) .catch((err) =&gt; { console.error(err); });","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"Promise","slug":"Promise","date":"2019-09-23T02:00:43.000Z","updated":"2021-07-15T11:49:00.170Z","comments":true,"path":"posts/23a0e66.html","link":"","permalink":"https://promisefine.github.io/posts/23a0e66.html","excerpt":"","text":"代码演示class myPromise { // 准备状态 static PENDING = 'pending' // 完成状态 static FULFILLED = 'fulfilled' // 失败状态 static REJECTED = 'rejected' constructor(executor) { this.status = myPromise.PENDING this.value = null this.callbacks = [] try { executor(this.resolve.bind(this), this.reject.bind(this)) } catch (error) { this.reject(error) } } // 类方法 // 成功 resolve(value) { // console.log(this) // 改变promise的状态 解决状态 if (this.status = myPromise.PENDING) { this.status = myPromise.FULFILLED this.value = value } // 变为异步任务 setTimeout(() =&gt; { this.callbacks.map(callback =&gt; { callback.onFulfilled(value) }) }); } // 失败 reject(reason) { if (this.status = myPromise.PENDING) { this.status = myPromise.REJECTED this.value = reason } // 变为异步任务 setTimeout(() =&gt; { this.callbacks.map(callback =&gt; { callback.onRejected(reason) }) }); } // then then(onFulfilled, onRejected) { if (typeof onFulfilled != 'function') { onFulfilled = () =&gt; { } } if (typeof onRejected != 'function') { onRejected = () =&gt; { } } // 当状态为准备状态 if (this.status == myPromise.PENDING) { this.callbacks.push({ onFulfilled: value =&gt; { try { onFulfilled(value) } catch (error) { onRejected(error) } }, onRejected: value =&gt; { try { onRejected(value) } catch (error) { onRejected(error) } } }) } // 当状态为完成的时候执行 if (this.status == myPromise.FULFILLED) { // 放到队列。轮询执行 setTimeout(() =&gt; { // 处理错误 try { onFulfilled(this.value) } catch (error) { onRejected(error) } }) } // 当状态为失败的时候执行 if (this.status == myPromise.REJECTED) { // 放到队列。轮询执行 setTimeout(() =&gt; { // 处理错误 try { onRejected(this.value) } catch (error) { onRejected(error) } }) } } }","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"debounce","slug":"debounce","date":"2019-09-21T02:24:47.000Z","updated":"2021-07-15T11:48:20.247Z","comments":true,"path":"posts/dbf34790.html","link":"","permalink":"https://promisefine.github.io/posts/dbf34790.html","excerpt":"","text":"代码演示const button = document.querySelector('button') function patMoney() { console.log('已剁') } // 创建一个防抖函数 function debounce(func, delay) { // 防止在定义监听函数的时候就直接执行了函数 所以我们用到高阶函数 let timer // 闭包 因为作用域链的关系 所有独立的执行函数都能访问到这个timer变量 return function () { let context = this let args = arguments clearTimeout(timer) // 设置setTimeout timer = setTimeout(function () { func.apply(context, args) }, delay) } } button.addEventListener('click', debounce(patMoney, 3000))","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"throttle","slug":"throttle","date":"2019-09-20T03:45:23.000Z","updated":"2021-07-15T11:48:12.739Z","comments":true,"path":"posts/ebdc48ec.html","link":"","permalink":"https://promisefine.github.io/posts/ebdc48ec.html","excerpt":"","text":"代码演示function coloring() { let r = Math.floor(Math.random() * 255) let g = Math.floor(Math.random() * 255) let b = Math.floor(Math.random() * 255) document.body.style.background = `rgb(${r},${g},${b})` } function throttle(func, delay) { let pre = 0 return function () { let now = new Date() let context = this let args = arguments if (now - pre &gt; delay) { func.apply(context, args) pre = now } } } window.addEventListener('resize', throttle(coloring, 2000))","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"热血发言","slug":"introduce","date":"2019-09-18T02:13:01.000Z","updated":"2021-07-15T11:46:05.400Z","comments":true,"path":"posts/3714eea.html","link":"","permalink":"https://promisefine.github.io/posts/3714eea.html","excerpt":"","text":"热爱互联网热爱前端热爱敲代码一包烟一杯茶一个Bug改一天我秃了但我变强了！","categories":[],"tags":[{"name":"introduce","slug":"introduce","permalink":"https://promisefine.github.io/tags/introduce/"}]}],"categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"},{"name":"Web","slug":"Web","permalink":"https://promisefine.github.io/tags/Web/"},{"name":"Http","slug":"Http","permalink":"https://promisefine.github.io/tags/Http/"},{"name":"introduce","slug":"introduce","permalink":"https://promisefine.github.io/tags/introduce/"}]}