{"meta":{"title":"Doney","subtitle":"如雪般明澈的双眸","description":"专科 | 计算机科学与技术 | 网络安全","author":"Doney","url":"https://promisefine.github.io","root":"/"},"pages":[{"title":"","date":"2021-07-12T00:45:59.560Z","updated":"2021-07-12T00:45:59.560Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://promisefine.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.354Z","comments":true,"path":"404.html","permalink":"https://promisefine.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.389Z","comments":true,"path":"List/index.html","permalink":"https://promisefine.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2021-07-12T00:45:59.563Z","updated":"2021-07-12T00:45:59.563Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://promisefine.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.558Z","comments":true,"path":"about/index.html","permalink":"https://promisefine.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.560Z","comments":true,"path":"categories/index.html","permalink":"https://promisefine.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.559Z","comments":true,"path":"archives/index.html","permalink":"https://promisefine.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-07-12T00:45:59.561Z","comments":true,"path":"census/index.html","permalink":"https://promisefine.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-14T06:09:43.269Z","comments":true,"path":"contact/index.html","permalink":"https://promisefine.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.564Z","comments":true,"path":"resource/index.html","permalink":"https://promisefine.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.566Z","comments":true,"path":"tags/index.html","permalink":"https://promisefine.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/index.html","permalink":"https://promisefine.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.390Z","comments":true,"path":"List/movies/index.html","permalink":"https://promisefine.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.391Z","comments":true,"path":"List/music/index.html","permalink":"https://promisefine.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.392Z","comments":true,"path":"List/tools/index.html","permalink":"https://promisefine.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://promisefine.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://promisefine.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-07-12T00:45:59.379Z","updated":"2021-07-12T00:45:59.379Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-07-12T00:45:59.380Z","updated":"2021-07-12T00:45:59.380Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://promisefine.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-07-12T00:45:59.382Z","updated":"2021-07-12T00:45:59.382Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-07-12T00:45:59.384Z","updated":"2021-07-12T00:45:59.384Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-07-12T00:45:59.386Z","updated":"2021-07-12T00:45:59.386Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-07-12T00:45:59.387Z","updated":"2021-07-12T00:45:59.387Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://promisefine.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"趣看项目","slug":"Interesting","date":"2021-07-17T01:57:42.000Z","updated":"2021-07-17T02:00:34.539Z","comments":true,"path":"posts/7f74a398.html","link":"","permalink":"https://promisefine.github.io/posts/7f74a398.html","excerpt":"","text":"","categories":[],"tags":[{"name":"Vite","slug":"Vite","permalink":"https://promisefine.github.io/tags/Vite/"},{"name":"Koa","slug":"Koa","permalink":"https://promisefine.github.io/tags/Koa/"}],"author":"Doney"},{"title":"vue项目架构搭建-4","slug":"vue项目架构搭建-4","date":"2020-05-23T13:15:24.000Z","updated":"2021-07-16T07:16:32.664Z","comments":true,"path":"posts/4260555f.html","link":"","permalink":"https://promisefine.github.io/posts/4260555f.html","excerpt":"","text":"vue项目架构搭建-4前言做这个 vueAdmin-template 的主要原因是: vue-element-admin 这个项目的初衷是一个 vue 的管理后台集成方案，把平时用到的一些组件或者经验分享给大家，同时它也在不断的维护和拓展中，比如最近重构了dashboard，加入了全屏功能，新增了 tabs-view 等等。所以项目会越来越复杂，不太适合很多初用 vue 的同学来构建后台。所以就写了这个基础模板，它没有复杂的功能，只包含了一个后台需要最基础的东西。 vueAdmin-template 主要是基于vue-cli webpack模板为基础开发的，引入了如下dependencies: element-ui 饿了么出品的vue2.0 pc UI框架 axios 一个现在主流并且很好用的请求库 支持Promise js-cookie 一个轻量的JavaScript库来处理cookie normalize.css 格式化css nprogress 轻量的全局进度条控制 vuex 官方状态管理 vue-router 官方路由 该项目只做了一个管理后台需要极简的功能，封装了axios请求，支持无限层级路由，动态权限和动态侧边栏。 如果需要更多复杂的功能可以参考 vue-element-admin，若还有不足，欢迎提issue或者pr。下文会简单说一下用该模板需要注意的地方。 路由懒加载路由懒加载应该是写大一点的项目都会用的一个功能，只有在使用这个component的时候才会加载这个相应的组件，这样写大大减少了初始页面 js 的大小并且能更好的利用游览器的缓存。 const Foo = resolve =&gt; require(['./Foo.vue'], resolve) //或者 const Foo = () =&gt; import('./Foo'); 在懒加载页面不多的情况下一切是那么的美好，但我司后台业务在不断地迭代，现在项目近百个路由，这时候使用路由懒加载在开发模式下就是一件痛苦的事情了，随手改一行代码热更新都是要6000ms+的，这怎么能忍。楼主整整花了一天多的时间找原因，能webpack优化的方法都用了,什么 dll, HappyPack 等方法都是过了，但提升的效果都不是很明显，正好那段时间出了 webpack3 楼主也升级了，编译速度也得到了很大幅度的提升，不过也要2000ms+。后来经过大神 @jzlxiaohei 的指点发现原来是路由懒加载搞得鬼，楼主猜测可能是异步加载导致 webpack 每次的 cache 失效了，所以每次的rebuild 才会这么的慢。找到了原因我们就可以对症下药了，我们就自己封装了一个_import()的方法，只有在正式环境下才使用懒加载。这样解决了困扰多事的rebuild慢问题。代码 const _import = require('./_import_' + process.env.NODE_ENV); const Foo = _import('Foo'); 整整比原来6000ms快了十多倍，我终于又能愉快的开发了。 权限 控制在手摸手，带你用vue撸后台 系列二(登录权限篇)这章中其实已经详细介绍过了。该项目中权限的实现方式是：通过获取当前用户的权限去比对路由表，生成当前用户具的权限可访问的路由表，通过router.addRoutes动态挂载到router上。 但其实很多公司的业务逻辑可能不是这样的，举一个例子来说，很多公司的需求是每个页面的权限是动态配置的，不像本项目中是写死预设的。但其实原理是相同的。如这个例子，你可以在后台通过一个tree控件或者其它展现形式给每一个页面动态配置权限，之后将这份路由表存储到后端。当用户登录后根据role，后端返回一个相应的路由表或者前端去请求之前存储的路由表动态生成可访问页面，之后就是router.addRoutes动态挂载到router上，你会发现原来是相同的，万变不离其宗。 导航侧边栏:本项目里的侧边栏是根据 router.js 配置的路由并且根据权限动态生成的，这样就省去了写一遍路由还要再手动写侧边栏这种麻烦事，同是使用了递归组件，这样不管你路由多少级嵌套，都能愉快的显示了。权限验证那里也做了递归的处理。 面包屑:本项目中也封装了一个面包屑导航，它也是通过watch $route动态生成的。代码 由于侧边栏导航和面包屑亦或是权限，你会发现其实都是和router密切相关的，所以基于vue-router路由信息对象上做了一下小小的拓展，自定义了一些属性 icon : the icon show in the sidebar hidden : if hidden:true will not show in the sidebar redirect : if redirect:noredirect will not redirct in the levelbar noDropdown : if noDropdown:true will not has submenu in the sidebar meta : { role: ['admin'] } will control the page role 大家也可以结合自己的业务需求增改这些自定义属性。 iconfontelement-ui自带的图标不是很丰富，但管理后台图标的定制性又很强。这里只给大家推荐使用阿里的 iconfont ，简单好用又方便管理。本项目中已经嵌入了一些 iconfont 作为例子，大家可以自行替换。 这里来简单介绍一下 iconfont 的使用方式。首先注册好 iconfont 账号之后，可以在我的项目中管理自己的 iconfont 。我司所有的项目都是用这个管理的，真心推荐使用。 创建好图标库后如果有更新替换也很方便，这里我使用了 Symbol 的方式引入，这里还有unicode，font-class的引入方式，有兴趣的可以自行研究。 之后我们点击下载 Symbol，会发现有如下这些文件，我们只要关心iconfont.js就可以了 我们将它替换项目中的 iconfont.js 就可以了。本项目中也封装了一个svg component 方便大家使用。 &lt;icon-svg icon-class=\"填入你需要的iconfont名字就能使用了\"&gt;&lt;/icon-svg&gt; favicon每个项目都需要有一个属于自己的favicon。 其实实现起来非常的方便，我们主需要借助html-webpack-plugin //webpack config function resolveApp(relativePath) { return path.resolve(relativePath); } new HtmlWebpackPlugin({ filename: config.build.index, template: 'index.html', inject: true, favicon: resolveApp('favicon.ico') }), 你只要将本项目跟目录下的favicon.ico文件替换为你想要的图标即可。 eslintvue cli 默认提供了standard和airbnb 两种 lint 规范，说真的一个j检查校验的太松一个又太紧，而且每个团队的 lint 规范又是不同的，所以楼主干脆在项目里把大部分常用的 lint 规范都列举了出来并写上了注释方便大家修改代码地址，大家也可以把自己的规范上传到npm，像 vue 一样 vue-eslint-config。配置 eslint 对多人协作的项目有很大的好处,同时配置好lint 在加 ide 的 lint 插件写代码简直要起飞。相关配置可见第一篇教程。 postcss相信大部分 vue 的项目都是基于 vue-cli 来开发的，不过毕竟每个人需求都是不太一样的，需要自定义一些的东西。就比如拿 postcss 来说 vue-cli 有一个小坑，它默认 autoprefixer 只会对通过 vue-loader 引入的样式有作用，换而言之也就是 .vue 文件里面的 css autoprefixer 才会效果。相关问题issues/544,issues/600。解决方案也很简单粗暴 //app.vue &lt;style lang=\"scss\"&gt; @import './styles/index.scss'; // 全局自定义的css样式 &lt;/style&gt; 你在 .vue 文件中引入你要的样式就可以了，或者你可以改变 vue-cli的文件在 css-loader 前面在加一个 postcss-loader，在前面的issue地址中已经给出了解决方案。 这里再来说一下 postcss 的配置问题，新版的vue-cli webpack 模板 inti 之后跟目录下默认有一个.postcssrc.js 。vue-loader 的 postcss 会默认读取这个文件的里的配置项，所以在这里直接改配置文件就可以了。配置和postcss是一样的。 //.postcssrc.js module.exports = { \"plugins\": { // to edit target browsers: use \"browserlist\" field in package.json \"autoprefixer\": {} } } //package.json \"browserslist\": [ \"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\" ] 如上代码所述，autoprefixe r回去读取 package.json 下 browserslist的配置文件 &gt; 1% 兼容全球使用率大于1%的游览器 last 2 versions 兼容每个游览器的最近两个版本 not ie &lt;= 8 不兼容ie8及以下 具体可见 browserslist, postcss也还有很多很多其它的功能大家可以自行去把玩 babel-polyfill本项目暂时没有兼容性需求，如有兼容性需求可自行使用babel-polyfill。 在Node/Browserify/webpack中使用 npm install --save babel-polyfill //下载依赖 在入口文件中引入 import 'babel-polyfill'; // 或者 require('babel-polyfill');//es6 在webpack.config.js中加入babel-polyfill到你的入口数组： module.exports = { entry:[\"babel-polyfill\",\"./app/js\"] } 具体可参考 link 或者更简单暴力 polyfill.io 使用它给的一个 cdn 地址，引入这段js之后它会自动判断游览器，加载缺少的那部分 polyfill，但国内速度肯能不行，大家可以自己搭 cdn。 跨域问题楼主 vue 群里的小伙伴们问的最多的问题还是关于跨域的，其实跨域问题真的不是一个很难解决的问题。这里我来简单总结一下我推荐的几种跨域解决方案。 我最推荐的也是我司常用的方式就是**cors**全称为 Cross Origin Resource Sharing（跨域资源共享）。这玩意对应前端来说和平时发请求写法上没有任何区别，工作量基本都在后端这里。每一次请求浏览器必须先以 OPTIONS 请求方式发送一个预请求，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。推荐的原因是只要第一次配好了，之后不管有多少接口和项目复用就可以了，一劳永逸的解决了跨域问题，而且不管是开发环境还是测试环境都能方便的使用。 但总有后端觉得麻烦不想这么搞。那前端也是有解决方案的，在 dev 开发模式下可以下使用**webpack 的 proxy使用也是很方便的看一下文档就会使用了，楼主一些个人项目使用的该方法。但这种方法在生成环境是不适用的。在生产环境中需要使 用Nginx反向代理** 不管是 proxy 和 nginx 的原理都是一样的通过搭建一个中转服务器来转发请求规避跨域的问题。 开发环境 生成环境 cors cors proxy nginx 这里我只推荐这两种方式跨域，其它的跨域方式都很多，但真心主流的也就这两种方式。 easy-mockvue-element-admin 由于是一个纯前端个人项目,所以所以的数据都是用mockjs生成的,它的原理是:拦截了所有的请求并代理到本地模拟数据，所以 network 中没有任何的请求发出。不过这并不符合实际业务开发中的场景，所以这个项目中使用了前不久刚出的 easy-mock，支持跨域，mockjs 的语法，支持Swagger 这几点还是挺不错的。相关文章 baseurl线上或者测试环境接口的 base_url 不一样是很长见得需求，或者你在本地用了如 easy-mock 这种模拟数据到线上环境你想用自己公司生产环境的数据，这些需求都可以简单的通过用 baseurl 来解决。首先我们在config/下有dev.env.js和prod.env.js这两个配置文件。用它来区分不同环境的配置参数。 //dev.env.js module.exports = { NODE_ENV: '\"development\"', BASE_API: '\"https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin\"', } //prod.env.js module.exports = { NODE_ENV: '\"production\"', BASE_API: '\"https://prod-xxx\"', } 同时本项目封装了axios拦截器，方便大家使用，大家也可根据自己的业务自行修改。 import axios from 'axios'; import { Message } from 'element-ui'; import store from '../store'; // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url 读取config配置文件 timeout: 5000 // 请求超时时间 }); // request拦截器 service.interceptors.request.use(config =&gt; { if (store.getters.token) { config.headers['X-Token'] = store.getters.token; // 让每个请求携带自定义token 请根据实际情况自行修改 } return config; }, error =&gt; { // Do something with request error console.log(error); // for debug Promise.reject(error); }) // respone拦截器 service.interceptors.response.use( response =&gt; { /** * code为非20000是抛错 可结合自己业务进行修改 */ const res = response.data; if (res.code !== 20000) { Message({ message: res.data, type: 'error', duration: 5 * 1000 }); // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; if (res.code === 50008 || res.code === 50012 || res.code === 50014) { MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { confirmButtonText: '重新登录', cancelButtonText: '取消', type: 'warning' }).then(() =&gt; { store.dispatch('FedLogOut').then(() =&gt; { location.reload();// 为了重新实例化vue-router对象 避免bug }); }) } return Promise.reject(error); } else { return response.data; } }, error =&gt; { console.log('err' + error);// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }); return Promise.reject(error); } ) export default service; 由于axios每一个都是一个实例，你的请求都是基于这个实例来的，所以所以配置的参数属性都继承了下来. //api.xxx.js import fetch from '@/utils/fetch'; export function getInfo(token) { return fetch({ url: '/user/info', method: 'get', params: { token } }); } //你可以直接这样使用，之前拦截器写的东西都是生效的， //它自动会有一个你之前配置的baseURL, //但你说我这个请求baseURL和其它的不同, //这也是很方便的，你可以字请求内部修改， //它会自动覆盖你在创建实例时候写的参数如 export function getInfo(token) { return fetch({ baseURL: https://api2-xxxx.com url: '/user/info', method: 'get', params: { token } }); } 总结这篇文章主要是介绍了 vueAdmin 做了哪些事情，希望大家如果有后台新项目要开发，建议基于 vue-admin-template 来开发，而 vue-element-admin 更多的是用来当做一个集成方案，你要什么功能就去里面找拿来用，因为两者的基础架构是一样的，所以复用成本也很低。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://promisefine.github.io/tags/Vue/"}],"author":"Doney"},{"title":"vue项目架构搭建-3","slug":"vue项目架构搭建-3","date":"2020-05-23T11:01:12.000Z","updated":"2021-07-16T07:14:52.217Z","comments":true,"path":"posts/dc04c0fc.html","link":"","permalink":"https://promisefine.github.io/posts/dc04c0fc.html","excerpt":"","text":"vue项目架构搭建-3前言在前面两篇文章中已经把基础工作环境构建完成，也已经把后台核心的登录和权限问题完成了，现在手摸手，一起进入实操。 Element去年十月份开始用 vue 做管理后台的时候毫不犹豫的就选择了 element-ui，那时候 vue2.0 刚发布也没多久，市面上也没有很多其它的 vue2.0 的 ui 框架可供选择。虽然 element-ui 也有很多的不足，前期的bug也不少，但我还是选择了它，简单说一下我选择element-ui的原因吧： 有大厂背书 : 虽然核心开发只有两三个人，但至少不用担心哪天就不维护，带着小姨子跑路了 持续迭代 : element-ui发版至今release了四十多个版本，之前平均都是一周一个小版本更新(是不是不小心暴露了它bug多的问题) 生态圈优异，社区活跃 ：其 contributors已经有250多人(前期我有饶有兴致的贡献过几个pr，参与过七八十个issue)，社区里也有很多基于element-ui 的拓展组件，也有很多相关的 qq 讨论群或者 gitter。 社区的认可:目前Element已经是vue相关最多star的开源项目了，体现出了社区对其的认可。 说了这么多优点，作为一个资深element-ui用户还是有些要抱怨的~和react老大哥 Ant Design 相比还是有一定的差距的，不管是组件的丰富性，参数的可配性还是文档的完整性，亦或是UI的交互和美观度。不过 ant 也是经过了近9k次commit的不断打磨，才有了今天。我也相信 element-ui也会越来越好的。 这里还有一些其它的框架(只讨论pc端的框架)大家可以自行选择： ivew 一国人个人写的框架，美观度和交互性都不错，有种介于Element和Ant之间的感觉，之前和element团队小小的撕了一下，有兴趣的自己去围观吧，框架还是很不做的，一个人能做出这样，也是很不容易的。作者公开信件 vue-admin 也是一个不错的选择，代码写的和不错，官方也出了一个admin的架子，也很值得借鉴 vue-material 一个material design vue框架库 vuetify 又是一个material design vue框架库 Keen-UI 又又是一个material design vue框架库 CoreUI-Free-Bootstrap-Admin-Template 和以前的Bootstrap一样，搭好了一个完整的架子，大家可以进行二次拓展，它有vue,react,angular多个版本 Framework7-Vue 个人感觉这是本人体验到现在移动端体验最好的框架。不过Framework7-Vue感觉还不是很完善，还需要观望一段时间。而且它有自己的路由规则，所以不能使用 vue-router，这点还是很不方便的。 简单列举了一些主流的框架，不得不感慨现在vue的生态圈真是太繁荣了，上述框架楼主并没有深入使用过，不好发表太多建议，大家自行甄别适合自己业务的框架吧。 这里开始我们会开始介绍一些结合Element的开发经验。 基于Element的动态换肤有些产品就是这么残忍，能完成需求就不错了，还要让我们做动态换肤。Element官网上也提供了自定义主题的方案 同时也提供了一个在线自定义主题的demo 是不是很酷，作者也说明了实现的方案 地址,大概思路: 先把默认主题文件中涉及到颜色的 CSS 值替换成关键词 根据用户选择的主题色生成一系列对应的颜色值 把关键词再换回刚刚生成的相应的颜色值 直接在页面上加 style 标签，把生成的样式填进去 我看完觉得真的还是有点复杂的。有没有简单的方案呢？ 让我们思考一下，让我们自己写动态换肤该怎么写呢？最常见的方法就是写两套主题，一套叫day theme ，一套叫night theme，night theme主题 都在一个.night-theme的命名空间下，我们动态的在body上add .night-theme ， remove .night-theme。这就是最简单的动态换肤。所以我们也能不能顺着这个思路，基于 element-ui 实现动态换肤呢？ 首先我们下载官方通过的 Theme generator ,一个专门用来生成Element主题的工具。按照文档，我们生成了需要的主题。 之后就是我们要做的事情了，将这个主题的每个元素外面包裹一个class 来做命名空间。 我们这里用到了gulp-css-wrap这个神器，轻轻松松就完成了我们想要的结果 var path = require('path') var gulp = require('gulp') var cleanCSS = require('gulp-clean-css'); var cssWrap = require('gulp-css-wrap'); var customThemeName='.custom-theme' gulp.task('css-wrap', function() { return gulp.src( path.resolve('./theme/index.css')) .pipe(cssWrap({selector:customThemeName})) .pipe(cleanCSS()) .pipe(gulp.dest('dist')); }); gulp.task('move-font', function() { return gulp.src(['./theme/fonts/**']).pipe(gulp.dest('dist/fonts')); }); gulp.task('default',['css-wrap','move-font']); 这样就得到了一个以.custom-theme为命名空间的自定义主题了，之后我们在项目中引入主题 //main.js import 'assets/custom-theme/index.css' 我们在换肤的地方toggleClass(document.body, 'custom-theme')一直toggle body 的 class就可以了。我们就简单实现了动态换肤效果。 不过这种模式实现换肤也是有一个弊端的，它等于把这两个主题都打包在了项目里，如果你的项目主题需要七八种，这种模式就不适合了。我们就需要动态的加载css，下面就是最简单的动态添加css的例子，当然你可以封装一下，增加成功或者失败回调，判断是否加载过改资源等等就不展开了。 var head = document.getElementsByTagName('HEAD').item(0); var style = document.createElement('link'); style.href = 'style.css'; style.rel = 'stylesheet'; style.type = 'text/css'; head.appendChild(style); 更新(2017.12) element-ui 官方更新了2.0版本，同时也提供了一个新的换肤思路。 文档 侧边栏这里又有谈一下导航栏的问题，本项目里的侧边栏是根据 router.js 配置的路由并且根据权限动态生成的，这样就省去了写一遍路由还要手动再写一次侧边栏这种麻烦事，但也遇到了一个问题，路由可能会有多层嵌套，很多人反馈自己的侧边栏会有三级，甚至还有五级的。所以重构了一下侧边栏，使用了递归组件，这样不管你多少级，都能愉快的显示了。代码 侧边栏高亮问题: 很多人在群里问为什么自己的侧边栏不能跟着自己的路由高亮，其实很简单，element-ui官方已经给了default-active所以我们只要 :default-active=\"$route.path\" 将default-active一直指向当前路由就可以了，就是这么简单。 点击侧边栏 刷新当前路由 在用 spa(单页面开发) 这种开发模式之前，大部分都是多页面后台，用户每次点击侧边栏都会重新请求这个页面，用户渐渐养成了点击侧边栏当前路由来刷新页面的习惯。但现在 spa 就不一样了，用户点击当前高亮的路由并不会刷新view，因为vue-router会拦截你的路由，它判断你的url并没有任何变化，所以它不会触发任何钩子或者是view的变化。issue地址，社区也对该问题展开了激烈讨论。 尤大本来也说要增加一个方法来强刷view，但后来他又改变了心意/(ㄒoㄒ)/~~。但需要就摆在这里，我们该怎么办呢？他说了不改变current URL 就不会触发任何东西，那我可不可以强行触发东西你？上有政策， 下有对策我们变着花来hack。方法也很简单，通过不断改变url的query来触发view的变化。我们监听侧边栏每个link 的 click事件，每次点击都给router push 一个不一样的query 来确保会重新刷新view。 clickLink(path) { this.$router.push({ path, query: { t: +new Date() //保证每次点击路由的query项都是不一样的，确保会重新刷新view } }) } 但这也有一个弊端就是 url 后面有一个很难看的 query 后缀如 xxx.com/article/list?t=1496832345025，但我司用户们表示能接受。。。只能暂时这样hack了，不知道大家有没有更好的方法，学习学习。 Table经过好几个版本的迭代，element-ui 的table组件已经能满足大部分业务需求了。不过rowSpan colSpan表格行/列合并现在并不是支持(element-ui2.0版本之后开始支持)。官方对此功能的更新情况可以关注这个issue。 这里我着重讲一下table表格几个常用的业务形态。 Table 拖拽排序这里主要是基于Sortable import Sortable from 'sortablejs' let el = document.querySelectorAll('.el-table__body-wrapper &gt; table &gt; tbody')[0] let sortable = Sortable.create(el) 在table mounted之后申明Sortable.create(el) table的每行tr就可以随意拖拽了，麻烦的目前我们的排序都是基于dom的，我们的数据层list并没有随之改变。所以我们就要手动的来管理我们的列表。 this.sortable = Sortable.create(el, { onEnd: evt =&gt; { //监听end事件 手动维护列表 const tempIndex = this.newList.splice(evt.oldIndex, 1)[0]; this.newList.splice(evt.newIndex, 0, tempIndex); } }); 这样我们就简单的完成了 table 拖拽排序。这里如果不是基于 dom 的排序推荐使用Vue.Draggable。完整代码 Table 内联编辑table内联编辑也是一个常见的需求。 其实也很简单，当我们拿到 list 数据之后先洗一下数据，每一条数据里面插入一个edit[ true or false ]判断符，来表示当前行是否处于编辑状态。之后就是通过v-show动态切换不同的相应view就可以了。完整代码 &lt;el-table-column min-width=\"300px\" label=\"标题\"&gt; &lt;template scope=\"scope\"&gt; &lt;el-input v-show=\"scope.row.edit\" size=\"small\" v-model=\"scope.row.title\"&gt;&lt;/el-input&gt; &lt;span v-show=\"!scope.row.edit\"&gt;{{ scope.row.title }}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column align=\"center\" label=\"编辑\" width=\"120\"&gt; &lt;template scope=\"scope\"&gt; &lt;el-button v-show='!scope.row.edit' type=\"primary\" @click='scope.row.edit=true' size=\"small\" icon=\"edit\"&gt;编辑&lt;/el-button&gt; &lt;el-button v-show='scope.row.edit' type=\"success\" @click='scope.row.edit=false' size=\"small\" icon=\"check\"&gt;完成&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; Table 常见坑通过dialog来编辑，新建，删除table的元素这种业务场景相对于前面说的两种更加的常见。而且也有不少的小坑。 首先我们要明确一个点 vue 是一个MVVM框架，我们传统写代码是命令式编程，拿到table这个dom之后就是命令式对dom增删改。而我们现在用声明式编程，只用关注data的变化就好了，所以我们这里的增删改都是基于list这个数组来的。这里我们还要明确一点vue 列表渲染注意事项 由于 JavaScript 的限制， Vue 不能检测以下变动的数组： * 当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue 所以我们想改变table中第一条数据的值，通过this.list[0]=newValue这样是不会生效的。 解决方案： // Array.prototype.splice` example1.items.splice(indexOfItem, 1, newValue) 所以我们可以通过 //添加数据 this.list.unshift(this.temp); //删除数据 const index = this.list.indexOf(row); //找到要删除数据在list中的位置 this.list.splice(index, 1); //通过splice 删除数据 //修改数据 const index = this.list.indexOf(row); //找到修改的数据在list中的位置 this.list.splice(index, 1,this.updatedData); //通过splice 替换数据 触发视图更新 这样我们就完成了对table的增删改操作，列表view也自动响应发生了变化。这里在修改数据的时候还有一个小坑需要主要。 当我们拿到需要修改行的数据时候不能直接将它直接赋值给dialog，不然会发生问题。 我们在dialog里面改变状态的时候，遮罩下面的table里面该行的状态也在那里跟着一只变化着。原因想必大家都猜到了。赋值的数据是一个objec引用类型共享一个内存区域的。所以我们就不能直接连等复制，需要重新指向一个新的引用，方案如下： //赋值对象是一个obj this.objData=Object.assign({}, row) //这样就不会共用同一个对象 //数组我们也有一个巧妙的防范 newArray = oldArray.slice(); //slice会clone返回一个新数组 Tabstab在后台项目中也比较常用的。假设我们有四个tab选项，每个tab都会向后端请求数据，但我们希望一开始只会请求当前的tab数据，而且tab来回切换的时候不会重复请求，只会实例化一次。首先我们想到的就是用v-if 这样的确能做到一开始不会挂载后面的tab，但有一个问题，每次点击这个tab组件都会重新挂载一次，这是我们不想看到的，这时候我们就可以用到``了。 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 它是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 所以我们就可以这样写tabs了 &lt;el-tabs v-model=\"activeTab\"&gt; &lt;el-tab-pane label=\"简介及公告\" name=\"announcement\"&gt; &lt;announcement /&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=\"资讯\" name=\"information\"&gt; &lt;keep-alive&gt; &lt;information v-if=\"activeTab=='information'\" /&gt; &lt;/keep-alive&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label=\"直播流配置\" name=\"stream\"&gt; &lt;keep-alive&gt; &lt;stream v-if=\"activeTab=='stream'\" /&gt; &lt;/keep-alive&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; Select 选择器Select 选择器直接使用没有什么太多问题，但很多时候我们需要通过Select来回显一些数据，当我们`` select 绑定一个obj value回显就会很蛋疼了，它要求必须保持同一个引用issue。这就意味着，我们回显数据的时候想先要找到该数据在arr中的位置，再回塞：demo。这还不是在远程搜索的情况下，如果是远程搜索的情况还要当疼。 这里推荐一下vue-multiselect 它能完美的解决前面Element select的问题。目前也是vue component 中比较好用的一个，ui也非常的好看，建议大家可以尝试性用一下，真的非常的不错。 Upload 上传Upload本身没什么好说的，文档写的蛮清楚了。这里主要说一下怎么将Upload组件和七牛直传结合在一起。 这里我们选择api直传的方式，就是我们首先要通过后端(go,node,php都可以)文档生成七牛上传必要的token(上传凭证)和key(资源的最终名称)。 所以现在只要想办法讲token和key塞进post请求里面就可以了，好在官方也提供了这个方法。 但怎么才能先异步的拿到token再将它塞入请求里呢？ 这时候我们又发现了before-upload 这个钩子还支持promise简直合我们的心意。 但我们写着写着怎样才能动态的改变之前的dataObj呢？通过看源码发现我们可以_self._data这样子拿到我们想要的数据。线上代码 &lt;template&gt; &lt;el-upload action=\"https://upload.qbox.me\" :data=\"dataObj\" drag :multiple=\"true\" :before-upload=\"beforeUpload\"&gt; &lt;i class=\"el-icon-upload\"&gt;&lt;/i&gt; &lt;div class=\"el-upload__text\"&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt; &lt;/el-upload&gt; &lt;/template&gt; &lt;script&gt; import { getToken } from 'api/qiniu'; // 获取七牛token 后端通过Access Key,Secret Key,bucket等生成token // 七牛官方sdk https://developer.qiniu.com/sdk#official-sdk export default{ data() { return { dataObj: { token: '', key: '' }, image_uri: [], fileList: [] } }, methods: { beforeUpload() { const _self = this; return new Promise((resolve, reject) =&gt; { getToken().then(response =&gt; { const key = response.data.qiniu_key; const token = response.data.qiniu_token; _self._data.dataObj.token = token; _self._data.dataObj.key = key; resolve(true); }).catch(err =&gt; { console.log(err) reject(false) }); }); } } } &lt;/script&gt; jsx在使用Element的时候，官方提供了很多可以自己写render function的地方，但由于Element内部都是用jsx 写render function的，所以demo也都是jsx，但很多人自己项目中其实是没有安装的，导致报错。但说真的用createElement裸写render 函数还是有些蛋疼。我们要用jsx，首先要安装 babel-plugin-transform-vue-jsx 安装方法如下： npm install\\ babel-plugin-syntax-jsx\\ babel-plugin-transform-vue-jsx\\ babel-helper-vue-jsx-merge-props\\ babel-preset-es2015\\ --save-dev .babelrc:文件 { \"presets\": [\"es2015\"], \"plugins\": [\"transform-vue-jsx\"] } 这样我们就可以愉快的使用 jsx 写render function了。 element 常见问题click事件不触发问题：一直有人在群里问Click Me怎么不触发click事件，虽然element文档还有完善的空间但这种问题大家还真要自己好好认真看一下官方的FAQ了。 官方说明了所有的原生事件必须添加 .native 修饰符。 修改element样式问题： 用ui组件总免不了需要对它做一些个性化定制的需求，所以我们就要覆盖element的一些样式。 首先我们要了解一下vue scoped是什么，很多人非常喜欢用scoped，妈妈再也不用担心样式冲突问题了，其实scoped也没有很神秘的，它就是基于PostCss的，加了一个作用局的概念。 //编译前 .example { color: red; } //编译后 .example[_v-f3f3eg9] { color: red; } 它和我们传统的命名空间的方法避免css冲突没有什么本质性的区别。 现在我们来说说怎么覆盖element-ui样式。由于element-ui的样式我们是在全局引入的，所以你想在某个view里面覆盖它的样式就不能加scoped，但你又想只覆盖这个页面的element样式，你就可在它的父级加一个class，以用命名空间来解决问题。 .aritle-page{ //你的命名空间 .el-tag { //element-ui 元素 margin-right: 0px; } } 建议向楼主一样专门建一个scss文件里专门自定义element-ui的各种样式。线上代码 其它关于element相关的东西真的没有什么好说的了，人家文档和源码就放在那里，有问题就去看文档，再去issue里找找，再去看看源码，大部分问题都能解决了。给一个诀窍其实大部分诡异的问题都可以通过加一个key或者 Vue.nextTick来解决。。 富文本管理后台富文本也是一个非常重要的功能，楼主在这里也踩了不少的坑。楼主在项目里最终选择了 tinymce 这里在简述一下推荐使用tinymce的原因：tinymce 是一家老牌做富文本的公司(这里也推荐 ckeditor，也是一家一直做富文本的公司，新版本很不错)，它的产品经受了市场的认可，不管是文档还是配置的自由度都很好。在使用富文本的时候有一点也很关键就是复制格式化，之前在用一款韩国人做的富文本summernote被它的格式化坑的死去活来，但 tinymce 的去格式化相当的好，它还有一个增值项目就是powerpaste,那是无比的强大，支持从word里面复制各种东西，都不会有问题。富文本还有一点也很关键，就是拓展性。楼主用tinymce写了好几个插件，学习成本和容易度都不错，很方便拓展。最后一点就是文档很完善，基本你想得到的配置项，它都有。tinymce也支持按需加载，你可以通过它官方的build页定制自己需要的plugins。 我再来分析一下市面上其它的一些富文本： summernote 先来说一个我绝对不推荐的富文本。这是一个韩国人开源的富文本(当然不推荐的理由不是因为这个)，它对很多富文本业界公认的默认行为理解是反起到而行的，而且只为用了一个dialog的功能，引入了boostrap，一堆人抗议就是不改。格式化也是差劲。。反正不要用！不要用！不要用！ ckeditor ckeditor也是一家老牌做富文本的公司，楼主旧版后台用的就是这个，今年也出了5.0版本，ui也变美观了不少，相当的不错，而且它号称是插件最丰富的富文本了。推荐大家也可以试用一下。 quill 也是一个非常火的富文本，长相很不错。基于它写插件也很简单，api设计也很简单。楼主不选择它的原因是它对图片的各种操作不友善，而且很难改。如果对图片没什么操作的用户，推荐使用。 medium-*editor* 大名鼎鼎的medium的富文本(非官方出品)，但完成度还是不很不错，拓展性也不错。不过我觉得大部分用户还是会不习惯medium这种写作方式的。 Squire 一个比较轻量的富文本，压缩完才11.5kb，相对于其它的富文本来说是非常的小了，推荐功能不复杂的建议使用。 wangEditor 一个国人写的富文本，用过感觉还是不错的。不过毕竟是个人的，不像专门公司做富文本的，配置型和丰富性不足。前端几大禁忌就有富文本 为什么都说富文本编辑器是天坑?，不过个人能做成这样子很不容易了。 百度UEditor 没有深入使用过，只在一个angular1X的项目简单用过，不过说着的ui真的不好看，不符合当今审美了，官方也已经很久没跟新过了。 楼主列举了很多富文本但并没有列举任何 vue 相关的富文本，主要是因为富文本真的比想象中复杂，在前面的文章里也说过了，其实用 vue 封装组件很方便的，没必要去用人家封装的东西什么vue-quill vue-editor这种都只是简单包了一层，没什么难度的。还不如自己来封装，灵活性可控性更强一点。还有一点基于 vue 真没什么好的富文本，不像 react 有 facebook 出的 draft-js，ory 出的 editor，这种大厂出的产品。 当然你也可以选择一些付费的富文本编辑器，作者自己公司里面有一个项目就使用了 froala-editor 这款编辑器。不管是美观和易用性都是不错的，公司买的是专业版，一年也就 $349 ，价格也是很合理的，但其实省去的程序员开发陈本可能远不止这个价钱。 Tinymce这里来简单讲一下在自己项目中使用 Tinymce 的方法。 由于目前使用 npm 安装 Tinymce 方法比较负责复杂而且还有一些问题(日后可能会采用该模式)。👾 目前采用全局引用的方式。代码地址：static/tinymce static目录下的文件不会被打包, 在 index.html 中引入。 使用 由于富文本不适合双向数据流，所以只会 watch 传入富文本的内容一次变化，只会就不会再监听了，如果之后还有改变富文本内容的需求。 可以通过 this.refs.xxx.setContent() 来设置 源码也很简单，有任何别的需求都可以在 @/components/Tinymce/index.vue 中自行修改。 Markdownmarkdown 我们这里选用了 simplemde-markdown-editor ，简单的用vue封装了一下地址,如果需求方能接受 markdown 就一定要用 markdown，坑真心会比富文本少很多。这里我们用markdown做了编辑器，还需要一个能解析的的东西。可以你传给后端让后端帮你转化，也可以前端自己来，这里推荐一个转化库showdown。使用方法： import('showdown').then(showdown =&gt; { //用了 Dynamic import const converter = new showdown.Converter();//初始化 this.html = converter.makeHtml(this.content)//转化 }) 用法也很简单两行代码就完成了markdown to html，当然它还有很多个性画的配置，大家有需求自行研究吧。 导出excel这里先明确一点，如果你的业务需求对导出文件的格式没有什么要求，不建议导出成xlsx格式的，直接导出成csv的就好了，真的会简单很多。创建一个a标签，写上data:text/csv;charset=utf-8头，再把数据塞进去，encodeURI(csvContent)一下就好了，详情就不展开了，大家可以借鉴这个stackoverflow回答。 我们重点说一下转xlsx，我们这里用到了js-xlsx，一个功能很强大excel处理库，只是下载各种格式excel，还支持读取excel，但上手难度也非常大，相当的复杂，其中涉及不少二进制相关的东西。不过好在官方给了我们一个demo例子,我们写不来还抄不来么，于是我们就借鉴官方的例子来改造了一下，具体原理就不详细说了，真的很复杂。。。 重点是我们怎么使用！首先我们封装一个Export2Excel.js， 它又依赖三个库 require('script-loader!file-saver'); //保存文件用 require('script-loader!vendor/Blob'); //转二进制用 require('script-loader!xlsx/dist/xlsx.core.min'); //xlsx核心 由于这几个文件不支持import引入，所以我们需要`script-loader`来将他们挂载到全局环境下。 它暴露了两个接口export_table_to_excel和export_json_to_excel,我们常用export_json_to_excel因为更加的可控一点，我们可以自由的洗数据。 handleDownload() { require.ensure([], () =&gt; { // 用 webpack Code Splitting xlsl还是很大的 const { export_json_to_excel } = require('vendor/Export2Excel'); const tHeader = ['序号', '文章标题', '作者', '阅读数', '发布时间']; // excel 表格头 const filterVal = ['id', 'title', 'author', 'pageviews', 'display_time']; const list = this.list; const data = this.formatJson(filterVal, list); // 自行洗数据 按序排序的一个array数组 export_json_to_excel(tHeader, data, '列表excel'); }) }， formatJson(filterVal, jsonData) { return jsonData.map(v =&gt; filterVal.map(j =&gt; v[j])) } 完整显示线上代码 ECharts管理后台图表也是常见得需求。这里图表就只推荐ECharts，功能齐全，社区demo也丰富gallery。我还是那个观点，大部分插件建议大家还是自己用vue来包装就好了，真的很简单。ECharts支持webpack引入，图省事可以将ECharts整个引入var echarts = require('echarts');不过ECharts还是不小的，我们大部分情况只是用到很少一部分功能，我平时习惯于按需引入的。 // 引入 ECharts 主模块 var echarts = require('echarts/lib/echarts'); // 引入柱状图 require('echarts/lib/chart/bar'); // 引入提示框和标题组件 require('echarts/lib/component/tooltip'); require('echarts/lib/component/title'); [webpack中使用ECharts文档](http://echarts.baidu.com/tutorial.html#在 webpack 中使用 ECharts) ECharts按需引入模块文档 接下来我们就要在vue中声明初始化ECharts了。因为ECharts初始化必须绑定dom，所以我们只能在vue的mounted生命周期里初始化。 mounted() { this.initCharts(); }, methods: { this.initCharts() { this.chart = echarts.init(this.$el); this.setOptions(); }, setOptions() { this.chart.setOption({ title: { text: 'ECharts 入门示例' }, tooltip: {}, xAxis: { data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"] }, yAxis: {}, series: [{ name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] }] }) } } 就这样简单，ECharts就配置完成了，这时候你想说我的data是远程获取的，或者说我动态改变ECharts的配置该怎么办呢？我们可以通过watch来触发setOptions方法 //第一种 watch options变化 利用vue的深度 watcher，options一有变化就重新setOption watch: { options: { handler(options) { this.chart.setOption(this.options) }, deep: true }, } //第二种 只watch 数据的变化 只有数据变化时触发ECharts watch: { seriesData(val) { this.setOptions({series:val}) } } 其实都差不多，还是要结合自己业务来封装。后面就和平时使用ECharts没有什么区别了。题外话ECharts的可配置项真心多，大家使用的时候可能要花一点时间了解它的api的。知乎有个问题：百度还有什么比较良心的产品？答案：ECharts，可见ECharts的强大与好用。 相同component 不同参数创建与编辑 其实后台创建与编辑功能是最常见的了，它区别去前台项目多了改的需求，但大部分创建页面与编辑页面字段和ui几乎是一样的，所以我们准备公用一个component来对应不同的页面。有两种常见的方法，来区别创建与编辑。 通过路由path的方式 这种方式最简单暴力，我自己的项目中使用这种方式，通过约定路径中出现’edit’就判断为编辑模式。比较省力和方便，不过这是要在大家写路径的时候都按照规范来写的前提下。 通过meta来区分 比较推荐这种方式来区分。 computed: { isEdit() { return this.$route.meta.isEdit // 根据meta判断 // return this.$route.path.indexOf('edit') !== -1 // 根据路由判断 } }， created() { if (this.isEdit) { this.fetchData(); } }, 就这样简单的实现了多路由复用了一个component，其实不只是创建和编辑可以这样用，如两个列表的一模一样，只是一个是内部文章另一个是调取外部文章都能复用组件，通过meta的方式来判断调取不同的接口。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://promisefine.github.io/tags/Vue/"}],"author":"Doney"},{"title":"vue项目架构搭建-2","slug":"vue项目架构搭建-2","date":"2020-05-23T09:10:36.000Z","updated":"2021-07-16T07:12:22.017Z","comments":true,"path":"posts/ab03f06a.html","link":"","permalink":"https://promisefine.github.io/posts/ab03f06a.html","excerpt":"","text":"vue项目架构搭建-2前言做后台项目区别于做其它的项目，权限验证与安全性是非常重要的，可以说是一个后台项目一开始就必须考虑和搭建的基础核心功能。我们所要做到的是：不同的权限对应着不同的路由，同时侧边栏也需根据不同的权限，异步生成。这里先简单说一下，我实现登录和权限验证的思路。 登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过token获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。 上述所有的数据和操作都是通过vuex全局管理控制的。(补充说明：刷新页面后 vuex的内容也会丢失，所以需要重复上述的那些操作)接下来，我们一起手摸手一步一步实现这个系统。 登录篇 首先我们不管什么权限，来实现最基础的登录功能。 随便找一个空白页面撸上两个input的框，一个是登录账号，一个是登录密码。再放置一个登录按钮。我们将登录按钮上绑上click事件，点击登录之后向服务端提交账号和密码进行验证。 这就是一个最简单的登录页面。如果你觉得还要写的更加完美点，你可以在向服务端提交之前对账号和密码做一次简单的校验。详细代码 click事件触发登录操作: this.$store.dispatch('LoginByUsername', this.loginForm).then(() =&gt; { this.$router.push({ path: '/' }); //登录成功之后重定向到首页 }).catch(err =&gt; { this.$message.error(err); //登录失败提示错误 }); action: LoginByUsername({ commit }, userInfo) { const username = userInfo.username.trim() return new Promise((resolve, reject) =&gt; { loginByUsername(username, userInfo.password).then(response =&gt; { const data = response.data Cookies.set('Token', response.data.token) //登录成功后将token存储在cookie之中 commit('SET_TOKEN', data.token) resolve() }).catch(error =&gt; { reject(error) }); }); } 登录成功后，服务端会返回一个 token（该token的是一个能唯一标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。 ps:为了保证安全性，可以将后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账号。 获取用户信息用户登录成功之后，我们会在全局钩子router.beforeEach中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了 //router.beforeEach if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetInfo').then(res =&gt; { // 拉取user_info const roles = res.data.role; next();//resolve 钩子 }) 就如前面所说的，我只在本地存储了一个用户的token，并没有存储别的用户信息（如用户权限，用户名，用户头像等）。有些人会问为什么不把一些其它的用户信息也存一下？主要出于如下的考虑： 假设我把用户权限和用户名也存在了本地，但我这时候用另一台电脑登录修改了自己的用户名，之后再用这台存有之前用户信息的电脑登录，它默认会去读取本地 cookie 中的名字，并不会去拉去新的用户信息。 所以现在的策略是：页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。 而且从代码层面我建议还是把 login和get_user_info两件事分开比较好，在这个后端全面微服务的年代，后端同学也想写优雅的代码~ 权限篇先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的 role ，动态根据用户的 role 算出其对应有权限的路由，再通过router.addRoutes动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是绝对安全的，后端的权限验证是逃不掉的。 可以在前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 header里面携带用户的 token，后端会根据该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。 权限 前端or后端 来控制？有很多人表示他们公司的路由表是于后端根据用户的权限动态生成的，但是，不采取这种方式的原因如下： 项目不断的迭代你会异常痛苦，前端新开发一个页面还要让后端配一下路由和权限，让我们想了曾经前后端不分离，被后端支配的那段恐怖时间了。 其次，就拿我司的业务来说，虽然后端的确也是有权限验证的，但它的验证其实是针对业务来划分的，比如超级编辑可以发布文章，而实习编辑只能编辑文章不能发布，但对于前端来说不管是超级编辑还是实习编辑都是有权限进入文章编辑页面的。所以前端和后端权限的划分是不太一致。 还有一点是就vue2.2.0之前异步挂载路由是很麻烦的一件事！不过好在官方也出了新的api，虽然本意是来解决ssr的痛点的。。。 addRoutes在之前通过后端动态返回前端路由一直很难做的，因为vue-router必须是要vue在实例化之前就挂载上去的，不太方便动态改变。不过好在vue2.2.0以后新增了router.addRoutes Dynamically add more routes to the router. The argument must be an Array using the same route config format with the routes constructor option. 有了这个我们就可相对方便的做权限控制了。(楼主之前在权限控制也走了不少歪路，可以在项目的commit记录中看到，重构了很多次，最早没用addRoute整个权限控制代码里都是各种if/else的逻辑判断，代码相当的耦合和复杂) 具体实现 创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。 当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。 调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 router.js首先我们实现router.js路由表，这里就拿前端控制路由来举例(后端存储的也差不多，稍微改造一下就好了) // router.js import Vue from 'vue'; import Router from 'vue-router'; import Login from '../views/login/'; const dashboard = resolve =&gt; require(['../views/dashboard/index'], resolve); //使用了vue-router的[Lazy Loading Routes](https://router.vuejs.org/en/advanced/lazy-loading.html) //所有权限通用路由表 //如首页和登录页和一些不用权限的公用页面 export const constantRouterMap = [ { path: '/login', component: Login }, { path: '/', component: Layout, redirect: '/dashboard', name: '首页', children: [{ path: 'dashboard', component: dashboard }] }, ] //实例化vue的时候只挂载constantRouter export default new Router({ routes: constantRouterMap }); //异步挂载的路由 //动态需要根据权限加载的路由表 export const asyncRouterMap = [ { path: '/permission', component: Layout, name: '权限测试', meta: { role: ['admin','super_editor'] }, //页面需要的权限 children: [ { path: 'index', component: Permission, name: '权限测试页', meta: { role: ['admin','super_editor'] } //页面需要的权限 }] }, { path: '*', redirect: '/404', hidden: true } ]; 这里我们根据 vue-router官方推荐 的方法通过meta标签来标示改页面能访问的权限有哪些。如meta: { role: ['admin','super_editor'] }表示该页面只有admin和超级编辑才能有资格进入。 注意事项：这里有一个需要非常注意的地方就是 404 页面一定要最后加载，如果放在constantRouterMap一同声明了404，后面的所以页面都会被拦截到404，详细的问题见addRoutes when you’ve got a wildcard route for 404s does not work main.js关键的main.js // main.js router.beforeEach((to, from, next) =&gt; { if (store.getters.token) { // 判断是否有token if (to.path === '/login') { next({ path: '/' }); } else { if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息 store.dispatch('GetInfo').then(res =&gt; { // 拉取info const roles = res.data.role; store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record }) }).catch(err =&gt; { console.log(err); }); } else { next() //当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面 } } } else { if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next(); } else { next('/login'); // 否则全部重定向到登录页 } } }); 这里的router.beforeEach也结合了上一章讲的一些登录逻辑代码。 上面一张图就是在使用addRoutes方法之前的权限判断，非常的繁琐，因为我是把所有的路由都挂在了上去，所有我要各种判断当前的用户是否有权限进入该页面，各种if/else的嵌套，维护起来相当的困难。但现在有了addRoutes之后就非常的方便，我只挂载了用户有权限进入的页面，没权限，路由自动帮我跳转的404,省去了不少的判断。 这里还有一个小hack的地方，就是router.addRoutes之后的next()可能会失效，因为可能next()的时候路由并没有完全add完成，好在查阅文档发现 next(‘/‘) or next({ path: ‘/‘ }): redirect to a different location. The current navigation will be aborted and a new one will be started. 这样我们就可以简单的通过next(to)巧妙的避开之前的那个问题了。这行代码重新进入router.beforeEach这个钩子，这时候再通过next()来释放钩子，就能确保所有的路由都已经挂在完成了。 store/permission.js就来就讲一讲 GenerateRoutes Action // store/permission.js import { asyncRouterMap, constantRouterMap } from 'src/router'; function hasPermission(roles, route) { if (route.meta &amp;&amp; route.meta.role) { return roles.some(role =&gt; route.meta.role.indexOf(role) &gt;= 0) } else { return true } } const permission = { state: { routers: constantRouterMap, addRouters: [] }, mutations: { SET_ROUTERS: (state, routers) =&gt; { state.addRouters = routers; state.routers = constantRouterMap.concat(routers); } }, actions: { GenerateRoutes({ commit }, data) { return new Promise(resolve =&gt; { const { roles } = data; const accessedRouters = asyncRouterMap.filter(v =&gt; { if (roles.indexOf('admin') &gt;= 0) return true; if (hasPermission(roles, v)) { if (v.children &amp;&amp; v.children.length &gt; 0) { v.children = v.children.filter(child =&gt; { if (hasPermission(roles, child)) { return child } return false; }); return v } else { return v } } return false; }); commit('SET_ROUTERS', accessedRouters); resolve(); }) } } }; export default permission; 这里的代码说白了就是干了一件事，通过用户的权限和之前在router.js里面asyncRouterMap的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些。 侧边栏最后一个涉及到权限的地方就是侧边栏，不过在前面的基础上已经很方便就能实现动态显示侧边栏了。这里侧边栏基于element-ui的NavMenu来实现的。 代码有点多不贴详细的代码了，有兴趣的可以直接去github上看地址，或者直接看关于侧边栏的文档。 说白了就是遍历之前算出来的permission_routers，通过vuex拿到之后动态v-for渲染而已。不过这里因为有一些业务需求所以加了很多判断 比如我们在定义路由的时候会加很多参数 /** * hidden: true if `hidden:true` will not show in the sidebar(default is false) * redirect: noredirect if `redirect:noredirect` will no redirct in the breadcrumb * name:'router-name' the name is used by &lt;keep-alive&gt; (must set!!!) * meta : { role: ['admin','editor'] will control the page role (you can set multiple roles) title: 'title' the name show in submenu and breadcrumb (recommend set) icon: 'svg-name' the icon show in the sidebar, noCache: true if fasle ,the page will no be cached(default is false) } **/ 这里仅供参考，而且本项目为了支持无限嵌套路由，所有侧边栏这块使用了递归组件。如需要请大家自行改造，来打造满足自己业务需求的侧边栏。 侧边栏高亮问题:很多人在群里问为什么自己的侧边栏不能跟着自己的路由高亮，其实很简单，element-ui官方已经给了default-active所以我们只要 :default-active=”$route.path” 将default-active一直指向当前路由就可以了，就是这么简单 按钮级别权限控制有很多人一直在问关于按钮级别粒度的权限控制怎么做。我司现在是这样的，真正需要按钮级别控制的地方不是很多，现在是通过获取到用户的role之后，在前端用v-if手动判断来区分不同权限对应的按钮的。理由前面也说了，我司颗粒度的权限判断是交给后端来做的，每个操作后端都会进行权限判断。而且我觉得其实前端真正需要按钮级别判断的地方不是很多，如果一个页面有很多种不同权限的按钮，我觉得更多的应该是考虑产品层面是否设计合理。当然你强行说我想做按钮级别的权限控制，你也可以参照路由层面的做法，搞一个操作权限表。。。但个人觉得有点多此一举。或者将它封装成一个指令都是可以的。 axios拦截器这里再说一说 axios 吧。虽然在上一篇系列文章中简单介绍过，不过这里还是要在唠叨一下。如上文所说，我司服务端对每一个请求都会验证权限，所以这里我们针对业务封装了一下请求。首先我们通过request拦截器在每个请求头里面塞入token，好让后端对请求进行权限验证。并创建一个respone拦截器，当服务端返回特殊的状态码，我们统一做处理，如没权限或者token失效等操作。 import axios from 'axios' import { Message } from 'element-ui' import store from '@/store' import { getToken } from '@/utils/auth' // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间 }) // request拦截器 service.interceptors.request.use(config =&gt; { // Do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } return config }, error =&gt; { // Do something with request error console.log(error) // for debug Promise.reject(error) }) // respone拦截器 service.interceptors.response.use( response =&gt; response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) { // Message({ // message: res.message, // type: 'error', // duration: 5 * 1000 // }); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // }).then(() =&gt; { // store.dispatch('FedLogOut').then(() =&gt; { // location.reload();// 为了重新实例化vue-router对象 避免bug // }); // }) // } // return Promise.reject('error'); // } else { // return response.data; // } error =&gt; { console.log('err' + error)// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) }) export default service 两步验证文章一开始也说了，后台的安全性是很重要的，简简单单的一个账号+密码的方式是很难保证安全性的。所以我司的后台项目都是用了两步验证的方式，之前我们也尝试过使用基于 google-authenticator 或者youbikey这样的方式但难度和操作成本都比较大。后来还是准备借助腾讯爸爸，这年代谁不用微信。。。安全性腾讯爸爸也帮我做好了保障。 楼主建议两步验证要支持多个渠道不要只微信或者QQ，前段时间QQ第三方登录就出了bug，官方两三天才修好的，害我背了锅/(ㄒoㄒ)/~~ 。 这里的两部验证有点名不副实，其实就是账号密码验证过之后还需要一个绑定的第三方平台登录验证而已。 写起来也很简单，在原有登录得逻辑上改造一下就好。 this.$store.dispatch('LoginByEmail', this.loginForm).then(() =&gt; { //this.$router.push({ path: '/' }); //不重定向到首页 this.showDialog = true //弹出选择第三方平台的dialog }).catch(err =&gt; { this.$message.error(err); //登录失败提示错误 }); 登录成功之后不直接跳到首页而是让用户两步登录，选择登录得平台。 接下来就是所有第三方登录一样的地方通过 OAuth2.0 授权。这个各大平台大同小异，大家自行查阅文档，不展开了，就说一个微信授权比较坑的地方。注意你连参数的顺序都不能换，不然会验证不通过。具体代码，同时我也封装了openWindow方法大家自行看吧。 当第三方授权成功之后都会跳到一个你之前有一个传入redirect——uri的页面 如微信还必须是你授权账号的一级域名。所以你授权的域名是vue-element-admin.com,你就必须重定向到vue-element-admin.com/xxx/下面，所以你需要写一个重定向的服务，如vue-element-admin.com/auth/redirect?a.com 跳到该页面时会再次重定向给a.com。 所以我们后台也需要开一个authredirect页面：代码。他的作用是第三方登录成功之后会默认跳到授权的页面，授权的页面会再次重定向回我们的后台，由于是spa，改变路由的体验不好，我们通过window.opener.location.href的方式改变hash，在login.js里面再监听hash的变化。当hash变化时，获取之前第三方登录成功返回的code与第一步账号密码登录之后返回的uid一同发送给服务端验证是否正确，如果正确，这时候就是真正的登录成功。 created() { window.addEventListener('hashchange', this.afterQRScan); }, destroyed() { window.removeEventListener('hashchange', this.afterQRScan); }, afterQRScan() { const hash = window.location.hash.slice(1); const hashObj = getQueryObject(hash); const originUrl = window.location.origin; history.replaceState({}, '', originUrl); const codeMap = { wechat: 'code', tencent: 'code' }; const codeName = hashObj[codeMap[this.auth_type]]; this.$store.dispatch('LoginByThirdparty', codeName).then(() =&gt; { this.$router.push({ path: '/' }); }); } 到这里涉及登录权限的东西也差不多讲完了，这里楼主只是给了大家一个实现的思路(都是楼主不断摸索的血泪史)，每个公司实现的方案都有些出入，请谨慎选择适合自己业务形态的解决方案。如果有什么想法或者建议欢迎去本项目下留言，一同讨论。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://promisefine.github.io/tags/Vue/"}],"author":"Doney"},{"title":"vue项目架构搭建-1","slug":"vue项目架构搭建-1","date":"2020-05-23T07:05:27.000Z","updated":"2021-07-16T07:10:06.607Z","comments":true,"path":"posts/320aa1d0.html","link":"","permalink":"https://promisefine.github.io/posts/320aa1d0.html","excerpt":"","text":"vue项目架构搭建-1前言说好的教程终于来了，第一篇文章主要来说一说在开始写实际业务代码之前的一些准备工作吧，但这里不会教你 webpack 的基础配置，热更新原理是什么，webpack速度优化等等，有需求的请自行 google，相关文章已经很多了。 目录结构├── build // 构建相关 ├── config // 配置相关 ├── src // 源代码 │ ├── api // 所有请求 │ ├── assets // 主题 字体等静态资源 │ ├── components // 全局公用组件 │ ├── directive // 全局指令 │ ├── filtres // 全局 filter │ ├── icons // 项目所有 svg icons │ ├── lang // 国际化 language │ ├── mock // 项目mock 模拟数据 │ ├── router // 路由 │ ├── store // 全局 store管理 │ ├── styles // 全局样式 │ ├── utils // 全局公用方法 │ ├── vendor // 公用vendor │ ├── views // view │ ├── App.vue // 入口页面 │ ├── main.js // 入口 加载组件 初始化等 │ └── permission.js // 权限管理 ├── static // 第三方不打包资源 │ └── Tinymce // 富文本 ├── .babelrc // babel-loader 配置 ├── eslintrc.js // eslint 配置项 ├── .gitignore // git 忽略项 ├── favicon.ico // favicon图标 ├── index.html // html模板 └── package.json // package.json 复制代码 这里来简单讲一下src文件 api 和 views简单截取一下公司后台项目，现在后台大概有四五十个 api 模块 如图可见模块有很多，而且随着业务的迭代，模块还会会越来越多。 所以这里建议根据业务模块来划分 views，并且 将views 和 api 两个模块一一对应，从而方便维护。 如 article 模块下放的都是文章相关的 api，这样不管项目怎么累加，api和views的维护还是清晰的，当然也有一些全区公用的api模块，如七牛upload，remoteSearch等等，这些单独放置就行。 components这里的 components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下，方便管理。 store这里我个人建议不要为了用 vuex 而用 vuex。就拿我司的后台项目来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，文章模块和评论模块几乎是俩个独立的东西，所以根本没有必要使用 vuex 来存储data，每个页面里存放自己的 data 就行。当然有些数据还是需要用 vuex 来统一管理的，如登录token,用户信息，或者是一些全局个人偏好设置等，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。总之还是那句话，不要为了用vuex而用vuex！ webpack 手搭webpack jquery (不建议用)管理后台不同于前台项目，会经常用到一些第三方插件，但有些插件是不得不依赖 jquery 的，如市面很多富文本基都是依赖 jquery 的，所以干脆就直接引入到项目中省事(gzip之后只有34kb，而且常年from cache,不要考虑那些吹毛求疵的大小问题，这几kb和提高的开发效率根本不能比)。但是如果第三方库的代码中出现!则会直接报错。要达到类似的效果，则需要使用 webpack 内置的 ProvidePlugin 插件，配置很简单，只需要 new webpack.ProvidePlugin({ $: 'jquery' , 'jQuery': 'jquery' }) 这样当 webpack 碰到 require 的第三方库中出现全局的$、jQeury和window.jQuery 时，就会使用 node_module 下 jquery 包 export 出来的东西了。 alias当项目逐渐变大之后，文件与文件直接的引用关系会很复杂，这时候就需要使用alias 了。 有的人喜欢alias 指向src目录下，再使用相对路径找文件 resolve: { alias: { '@': resolve(__dirname, 'src') } } //使用 import stickTop from '@/components/stickTop' 或者也可以 alias: { 'src': path.resolve(__dirname, '../src'), 'components': path.resolve(__dirname, '../src/components'), 'api': path.resolve(__dirname, '../src/api'), 'utils': path.resolve(__dirname, '../src/utils'), 'store': path.resolve(__dirname, '../src/store'), 'router': path.resolve(__dirname, '../src/router') } //使用 import stickTop from 'components/stickTop' import getArticle from 'api/article' 没有好与坏对与错，纯看个人喜好和团队规范。 ESLint不管是多人合作还是个人项目，代码规范是很重要的。这样做不仅可以很大程度地避免基本语法错误，也保证了代码的可读性。这所谓工欲善其事，必先利其器，个人推荐 eslint+vscode 来写 vue，绝对有种飞一般的感觉。 每次保存，vscode就能标红不符合eslint规则的地方，同时还会做一些简单的自我修正。安装步骤如下： 首先安装eslint插件 安装并配置完成 ESLint 后，我们继续回到 VSCode 进行扩展设置，依次点击 文件 &gt; 首选项 &gt; 设置 打开 VSCode 配置文件,添加如下配置 \"files.autoSave\":\"off\", \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"html\", { \"language\": \"vue\", \"autoFix\": true } ], \"eslint.options\": { \"plugins\": [\"html\"] } 这样每次保存的时候就可以根据根目录下.eslintrc.js你配置的eslint规则来检查和做一些简单的fix。这里提供了一份我平时的eslint规则地址，都简单写上了注释。每个人和团队都有自己的代码规范，统一就好了，去打造一份属于自己的eslint 规则上传到npm吧，如饿了么团队的 config，vue的 config。 vscode 插件和配置推荐 封装 axios我们经常遇到一些线上 的bug，但测试环境很难模拟。其实可以通过简单的配置就可以在本地调试线上环境。 这里结合业务封装了axios ，线上代码 import axios from 'axios' import { Message } from 'element-ui' import store from '@/store' import { getToken } from '@/utils/auth' // 创建axios实例 const service = axios.create({ baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // 请求超时时间 }) // request拦截器 service.interceptors.request.use(config =&gt; { // Do something before request is sent if (store.getters.token) { config.headers['X-Token'] = getToken() // 让每个请求携带token--['X-Token']为自定义key 请根据实际情况自行修改 } return config }, error =&gt; { // Do something with request error console.log(error) // for debug Promise.reject(error) }) // respone拦截器 service.interceptors.response.use( response =&gt; response, /** * 下面的注释为通过response自定义code来标示请求状态，当code返回如下情况为权限有问题，登出并返回到登录页 * 如通过xmlhttprequest 状态码标识 逻辑可写在下面error中 */ // const res = response.data; // if (res.code !== 20000) { // Message({ // message: res.message, // type: 'error', // duration: 5 * 1000 // }); // // 50008:非法的token; 50012:其他客户端登录了; 50014:Token 过期了; // if (res.code === 50008 || res.code === 50012 || res.code === 50014) { // MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', { // confirmButtonText: '重新登录', // cancelButtonText: '取消', // type: 'warning' // }).then(() =&gt; { // store.dispatch('FedLogOut').then(() =&gt; { // location.reload();// 为了重新实例化vue-router对象 避免bug // }); // }) // } // return Promise.reject('error'); // } else { // return response.data; // } error =&gt; { console.log('err' + error)// for debug Message({ message: error.message, type: 'error', duration: 5 * 1000 }) return Promise.reject(error) }) export default service import request from '@/utils/request' //使用 export function getInfo(params) { return request({ url: '/user/info', method: 'get', params }); } 比如后台项目，每一个请求都是要带 token 来验证权限的，这样封装以下的话我们就不用每个请求都手动来塞 token，或者来做一些统一的异常处理，一劳永逸。 而且因为我们的 api 是根据 env 环境变量动态切换的，如果以后线上出现了bug，我们只需配置一下 @/config/dev.env.js 再重启一下服务，就能在本地模拟线上的环境了。 module.exports = { NODE_ENV: '\"development\"', BASE_API: '\"https://api-dev\"', //修改为'\"https://api-prod\"'就行了 APP_ORIGIN: '\"https://wallstreetcn.com\"' //线上地址 pc站为vue+ssr } 妈妈再也不用担心我调试线上bug了。 当然这里只是简单举了个例子，axios还可以执行多个并发请求，拦截器什么的，大家自行去研究吧。 多环境vue-cli 默认只提供了dev和prod两种环境。但其实正真的开发流程可能还会多一个sit或者stage环境，就是所谓的测试环境和预发布环境。所以我们就要简单的修改一下代码。其实很简单就是设置不同的环境变量 \"build:prod\": \"NODE_ENV=production node build/build.js\", \"build:sit\": \"NODE_ENV=sit node build/build.js\", 之后在代码里自行判断，想干就干啥 var env = process.env.NODE_ENV === 'production' ? config.build.prodEnv : config.build.sitEnv 新版的 vue-cli 也内置了 webpack-bundle-analyzer 一个模块分析的东西，相当的好用。使用方法也很简单，和之前一样封装一个 npm script 就可以。 //package.json \"build:sit-preview\": \"cross-env NODE_ENV=production env_config=sit npm_config_preview=true npm_config_report=true node build/build.js\" //之后通过process.env.npm_config_report来判断是否来启用webpack-bundle-analyzer var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin()) webpack-bundle-analyzer这个插件还是很有用的，对后期的代码优化什么的，最重要的是它够装逼~ 前后端交互每个公司都有自己一套的开发流程，没有绝对的好与坏。这里我来讲讲我司的前后端交互流程。 跨域问题首先前后端交互不可避免的就会遇到跨域问题，我司现在全是用 cors来解决的，如果你司后端嫌麻烦不肯配置的话，dev环境也可以通过 webpack-dev-server的proxy来解决，开发环境用nginx反代理一下就好了，具体配置这里就不展开了。 前后端的交互问题其实大家也知道，平时的开发中交流成本占据了我们很大一部分时间，但前后端如果有一个好的协作方式的话能解决很多时间。我司开发流程都是前后端和产品一起开会讨论项目，之后后端根据需求，首先定义数据格式和api，然后 mock api 生成好文档，我们前端才是对接接口的。这里推荐一个文档生成器 swagger。 swagger是一个REST APIs文档生成工具，可以在许多不同的平台上从代码注释中自动生成，开源，支持大部分语言，社区好，总之就是一个强大，如下图的api 文档(swagger自动生成，ui忽略) api 地址，需要传是没参数，需要的传参类型，返回的数据格式什么都一清二楚了。 前端自行mock如果后端不肯来帮你 mock 数据的话，前端自己来 mock 也是很简单的。你可以使用mock server 或者使用 mockjs + rap 也是很方便的。 不久前出的 easy-mock也相当的不错，还能结合 swagger。 我们大前端终于不用再看后端的脸色了~ iconfontelement-ui 默认的icon不是很多，这里要安利一波阿里的iconfont简直是神器，不管是公司项目还是个人项目都在使用。它提供了png,ai,svg三种格式，同时使用也支持unicode，font-class，symbol三种方式。 详细具体的使用可以见文章 手摸手，带你优雅的使用 icon router-viewdifferent router the same component vue。真实的业务场景中，这种情况很多。 我创建和编辑的页面使用的是同一个component,默认情况下当这两个页面切换时并不会触发vue的created或者mounted钩子，官方说你可以通过watch $route的变化来做处理，但其实说真的还是蛮麻烦的。后来发现其实可以简单的在 router-view上加上一个唯一的key，来保证路由切换时都会重新渲染触发钩子了。这样简单的多了。 &lt;router-view :key=\"key\"&gt;&lt;/router-view&gt; computed: { key() { return this.$route.name !== undefined? this.$route.name + +new Date(): this.$route + +new Date() } } 优化有些人会觉得现在构建是不是有点慢，可以提升技术栈为容器服务，后台项目会把dist文件夹里的东西都会打包成一个docker镜像，基本步骤为 npm install npm run build:prod 加打包镜像，一共是耗时如下 还是属于能接受时间的范围。 主站PC站基于nodejs、Vue实现服务端渲染，所以不仅需要依赖nodejs，而且需要利用pm2进行nodejs生命周期的管理。为了加速线上镜像构建的速度，我们利用taobao源 registry.npm.taobao.org 进行加速, 并且将一些常见的npm依赖打入了基础镜像，避免每次都需要重新下载。 这里注意下 建议不要使用cnpm install或者update 它的包都是一个link，反正会有各种诡异的bug，这里建议这样使用 npm install --registry=https://registry.npm.taobao.org 如果你觉得慢还是有可优化的空间如使用webpack dll 或者把那些第三方vendor单独打包 external出去，或者我司现在用的是http2 可以使用AggressiveSplittingPlugin等等，这里有需求的可以自行优化。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://promisefine.github.io/tags/Vue/"}],"author":"Doney"},{"title":"架构图以及vue的简介","slug":"vue简介","date":"2020-05-08T08:48:01.000Z","updated":"2021-07-16T06:49:55.328Z","comments":true,"path":"posts/c0add594.html","link":"","permalink":"https://promisefine.github.io/posts/c0add594.html","excerpt":"","text":"[架构图以及vue的简介]架构图前后端分离总架构图 前端架构设计图 MVVM 架构模式MVVM 的简介MVVM 由 Model,View,ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 MVVM 模式图 vue1. 学习 vue 的前提 你只需要了解关于 HTML、CSS 和 JavaScript 的中级知识，就能进行开发。 vue用于构建用户界面的渐进式框架，渐进式代表的含义是：主张最少。每个框架都不可避免会有自己的一些特点，从而会对使用者有一定的要求，这些要求就是主张，主张有强有弱，它的强势程度会影响在业务开发中的使用方式。 Vue可能有些方面是不如React，不如Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用OO和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事，仅此而已。 我们没必要一上来就搞懂Vue的每一个部件和功能，先从核心功能开始学习，逐渐扩展。 同时，在使用中，我们也没有必要把全部件能都拿出来，需要什么用什么就是了，而且也可以把Vue很方便的与其它已有项目或框架相结合 2. vue 的简单介绍Vue.js 可以说是MVVM 架构的最佳实践，是一个JavaScriptMVVM库，是一套构建用户界面的渐进式框架。专注于 MVVM 中的 ViewModel，不仅做到了数据双向绑定，而且也是一款相对比较轻量级的JS 库，API 简洁 3. vue 热加载因为vue的双向数据绑定特性以及技术的成形，实现了项目的热加载，改完页面代码能立即在浏览器方面显示效果，提高开发效率 4. vue 的双向数据绑定的原理Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。 Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。 5. vue 引用与后台的交互在访问一个 API 并展示其数据，基于 promise 的 HTTP 客户端 axios 则是其中非常流行的一种， 首先，我们要通过 npm/Yarn 或一个 CDN 链接安装 axios， 我们有很多种方式可以从 API 请求信息，但是最好首先确认这些数据看起来长什么样，以便进一步确定如何展示它。为此，我们会调用一次这个 API 并输出结果，以便我们能够看清楚它。如 CoinDesk 的 API 文档所述，请求会发送到 https://api.coindesk.com/v1/bpi/currentprice.json。所以，我们首先创建一个 data 里的属性以最终放置信息，然后将会在 mounted 生命周期钩子中获取数据并赋值过去： new Vue({ el: '#app', data () { return { info: null } }, mounted () { axios .get('https://api.coindesk.com/v1/bpi/currentprice.json') .then(response =&gt; (this.info = response)) } }) &lt;div id=\"app\"&gt; {{ info }} &lt;/div&gt; 我们得到的东西是这样的： { \"USD\": { \"code\": \"USD\", \"symbol\": \"&amp;#36;\", \"rate\": \"5,255.3433\", \"description\": \"United States Dollar\", \"rate_float\": 5255.3433 }, \"GBP\": { \"code\": \"GBP\", \"symbol\": \"&amp;pound;\", \"rate\": \"4,061.1927\", \"description\": \"British Pound Sterling\", \"rate_float\": 4061.1927 }, \"EUR\": { \"code\": \"EUR\", \"symbol\": \"&amp;euro;\", \"rate\": \"4,699.5277\", \"description\": \"Euro\", \"rate_float\": 4699.5277 } } 当然这个只是一个非常简单的示例，在项目开发过程中，我们会基于axios做一些封装，包括错误处理，请求拦截，请求优化等等 6. vue 常用的网站vue官方文档：https://cn.vuejs.org/v2/guide/ vue资源精选：http://vue.awesometiny.com/ vue GitHub地址：https://github.com/vuejs/vue 基于vue和element构建的后台前端解决方案：https://panjiachen.github.io/vue-element-admin-site/zh/ vue 项目说明vue项目网上有非常多的成名模板，我推荐一个，想深入学习建议多多浏览下面的地址 vue和element构建的后台前端解决方案：&lt;https://panjiachen.github.io/vue-element-admin-site/zh/ 目录结构├── build # 构建相关├── static # 静态资源│ │── img # 图片│ │── favicon.ico # favicon图标│ └── index.html # html模板│ │── Tinymce # 富文本├── src # 源代码│ ├── api # 所有请求│ ├── assets # 主题 字体等静态资源│ ├── components # 全局公用组件│ ├── directive # 全局指令│ ├── icons # 项目所有 svg icons│ ├── lang # 国际化 language│ ├── layout # 全局 layout│ ├── router # 路由│ ├── store # 全局 store管理│ ├── styles # 全局样式│ ├── utils # 全局公用方法│ ├── views # views 所有页面│ ├── App.vue # 入口页面│ ├── main.js # 入口文件 加载组件 初始化等│ └── permission.js # 权限管理├── tests # 测试├── .env.xxx # 环境变量配置├── .eslintrc.js # eslint 配置项├── .gitignore # git 配置项├── .babelrc # babel-loader 配置├── .travis.yml # 自动化CI配置├── vue.config.js # vue-cli 配置└── package.json # package.json 此为常见的目录结构，在实际开发过程中，会因为项目的差异，目录有些小的改动。 项目启动在终端 # 进入项目目录（假设项目名为：vue-element-admin） cd vue-element-admin # 安装依赖 npm install # 本地开发 启动项目 npm run dev # 启动完成我们就能在，提示的地址中，浏览或开发项目（例如地址为：http://127.0.0.1:9528） http://127.0.0.1:9528 url**到页面显示的过程** 浏览器端显示HTML的过程","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://promisefine.github.io/tags/Vue/"}],"author":"Doney"},{"title":"webpack","slug":"webpack","date":"2020-03-15T06:39:22.000Z","updated":"2021-07-16T06:49:19.589Z","comments":true,"path":"posts/b9f20a20.html","link":"","permalink":"https://promisefine.github.io/posts/b9f20a20.html","excerpt":"","text":"webpack可以做的事情 代码转换、文件优化、代码分割、模块合并、自动刷新、代码校验、自动发布 最终目的 webpack的基本配置 webpack的高级配置 webpack的优化策略 ast抽象语法树 webpack的Tapable 掌握webpack的流程 手写webpack 手写webpack中常见的loader 手写webpack中常见的plugin 1. 安装webpack webpack:提供了内置的东西 express plugin webpack-cli: npx webpack 服务: webpack-dev-server:启动服务 proxy beforeapp 不会真正的打包文件, 只会在内存中打包 运行命令 npx webpack-dev-server 2.配置文件let path = require(\"path\"); let HtmlWebpackPlugin = require(\"html-webpack-plugin\"); module.exports = {//webpack 是node中的一个模块 CommonJs devServer: {//静态服务器的配置 port: 3000, progress: true,//进度提哦啊 contentBase: \"./dist\",//静态资源路径 compress:true//是否压缩Gzip }, mode: \"production\",//环境 entry: \"./src/index.js\", output: { filename: \"bundle[hash:8].js\",//设置hash之后会解决浏览器缓存问题 path: path.resolve(__dirname, \"dist\")//解析 会把相对路径解析成绝对路径 }, plugins: [ new HtmlWebpackPlugin({//打包的时候 自动把html打包到dist目录 template: \"./src/index.html\", filename: \"index.html\", minify:{ removeAttributeQuotes:true,//去除双引号 collapseWhitespace:true//单行压缩 }, hash:true//是否加hash后缀 }) ] }; 思考1: 如何压缩html文件 思考2: 如何实现命名的hash串 plugins:[ new HtmlWebpackPlugin({ template: './src/index.html', filename: 'index.html', minify: { collapseWhitespace: true, removeAttributeQuotes: true }, hash: true }) ] 2.1 修改样式2.2.1 loader配置如果直接插入css文件会报错 解决: 下载两个loader module: {//模块 rules: [//规则 { test: /\\.css$/, use: [{ loader: 'style-loader',//将css插入到head中 options: { insert: 'top'//head/top foot } }, 'css-loader'] }, { test: /\\.scss$/, use: ['style-loader','css-loader', 'sass-loader'] } ], }, 2.1.1 分离css但是 此时 我们打包后发现 css是插入在js里面 为了解决这个问题 接下来我们引入 mini-css-extract-plugin这个插件 let MiniCssExtractPlugin require('mini-css-extract-plugin') rules: [ { test: /\\.css$/, use: [{ loader: MiniCssExtractPlugin.loader, }, 'css-loader']//loader顺序的规律 }, { test: /\\.(sc|sa)ss$/, use: [{ loader: MiniCssExtractPlugin.loader, }, 'css-loader', 'sass-loader']//loader顺序的规律 } ] 当我们加入css3之后 新的问题出现了 没有前缀 2.1.3 引入前缀此时 我们需要下载一个包autoprefixer以及一个loader文件postcss-loader { test: /\\.css$/, use: [{ loader: MiniCssExtractPlugin.loader, }, 'css-loader','postcss-loader']//loader顺序的规律 }, 创建一个配置文件 postcss.config.js module.exports = { plugins: [require('autoprefixer')] }; 再次打包 需要注意的是 此设置项只能用早生产环境 mode: 'production', 2.1.4 压缩css文件如何压缩文件呢 其中有个包 optimize-css-assets-webpack-plugin 此包主要是用来压缩css的 但是 引入这个包后出现了js没被压缩的问题 怎么解决呢 按照官网配置需要使用TerserJSPlugin https://www.npmjs.com/package/mini-css-extract-plugin optimization: {//webpack4.0之后新出的优化项配置 minimizer: [new TerserJSPlugin({}), new OptimizeCssAssetsPlugin({})] }, TerserJSPlugin具体参数查看这个 interface TerserPluginOptions { test?: string | RegExp | Array&lt;string | RegExp&gt;; include?: string | RegExp | Array&lt;string | RegExp&gt;; exclude?: string | RegExp | Array&lt;string | RegExp&gt;; chunkFilter?: (chunk: webpack.compilation.Chunk) =&gt; boolean; cache?: boolean | string; cacheKeys?: (defaultCacheKeys: any, file: any) =&gt; object; parallel?: boolean | number; sourceMap?: boolean; minify?: (file: any, sourceMap: any) =&gt; MinifyResult; terserOptions?: MinifyOptions; extractComments?: boolean | string | RegExp | ExtractCommentFn | ExtractCommentOptions; warningsFilter?: (warning: any, source: any) =&gt; boolean; } 2.2 处理js文件2.2.1 babel核心模块当我们尝试对写了es6语法的代码进行打包时候并没有变成es5 接下来执行命令 babel yarn add babel-loader @babel/core @babel/preset-env babel-loader : babel加载器 @babel/core : babel的核心模块 @babel/preset-env : 将es6转换成es5 @babel/plugin-transform-runtime @babel/runtime @babel/polyfill { test: /\\.js$/, use: [ { loader: 'babel-loader', options: {//预设 presets: ['@babel/preset-env'] } } ] } 2.2.2 处理箭头函数@babel/preset-env 2.2.3 处理装饰器当我们添加装饰器 会有如下提示 具体可以查看官网 https://babeljs.io/docs/en/babel-plugin-proposal-decorators { test: /\\.js$/, use: [ { loader: 'babel-loader', options: {//预设 presets: ['@babel/preset-env'], plugins:[ [\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], [\"@babel/plugin-proposal-class-properties\", { \"loose\" : true }] ] } } ] }, index.js @log class A { a = 1;//es7 的语法(es6的变种语法) // let a = new A() a.a = 1 } function log(target) { console.log(target,'21'); } 2.2.4 处理es7语法{ test: /\\.js$/, use: [ { loader: 'babel-loader', options: {//预设 presets: ['@babel/preset-env'], plugins:['@babel/plugin-proposal-class-properties'] } } ] } a.js class B { } function* fnB() { yield 1; } console.log(fnB().next()); module.exports = 'a'; 接下来打包发现 每个文件都会打包一个_classCallCheck 写了generator运行也会报错 出现以上问题的原因是 在webpack运行时不会自动检测哪些方法重用了 一些es6的高级语法 比如generator和promise不会转换成es5 根据官方文档https://babeljs.io/docs/en/babel-plugin-transform-runtime#docsNav 需要下载两个包 yarn add @babel/plugin-transform-runtime @babel/runtime -D 执行npx webpack但是 报了一些警告 { test: /\\.js$/, use: [ { loader: 'babel-loader', options: {//预设 presets: ['@babel/preset-env'], plugins: [ [\"@babel/plugin-proposal-decorators\", {\"legacy\": true}], [\"@babel/plugin-proposal-class-properties\", {\"loose\": true}], \"@babel/plugin-transform-runtime\" ] } } ], include: path.resolve(__dirname, 'src'), exclude: /node_modules/ }, 2.2.5 处理全局变量的问题方法一 : 外置loader require('expose-loader?$!jquery'); 方法二 : 内置loader在每个模块都注入$ // rules: {//内置loader test: require.resolve('jquery'), use: 'expose-loader?$' }, // plugins: //提供者 new webpack.ProvidePlugin({ \"$\": \"jquery\" }) 优化: 如果在html引入cdn路径并且在页面也 import $ from jquery 这就坏了, 即使引入cdn也会打包 //排除之外 加入 在cdn引入了这个包 就不会打包这个包 externals: { 'jquery': '$ } 2.3 处理图片文件2.3.1 处理js中的图片index.js import logo from './logo.png'; &lt;img src=logo/&gt; webpack.config.js: { test: /\\.(png|jpg|gif)$/, use: [{ loader: 'file-loader', options: { esModule: false, }, } } 2.3.2 处理css中图片文件因为css-loader中已经对图片做loader处理了 所以 只需要引入相应路径就行了 2.3.3 处理html中的图片//1. 下载依赖 yarn add html-withimg-plugin -D //2. 配置 { test:/\\.html$/, use:['html-withimg-plugin'] } 2.4 多入口多出口2.5 webpack小插件 clean-webpack-plugin let {CleanWebpackPlugin} = require('clean-webpack-plugin'); //使用: plugins:[ new CleanWebpackPlugin() ] copy-webpack-plugin const CopyPlugin = require('copy-webpack-plugin'); module.exports = { plugins: [ new CopyPlugin([ { from: 'source', to: 'dest' }, { from: 'other', to: 'public' }, ]), ], }; 2.6 resolve、分离2.6.1 resolveresolve:{ modules:[path.resolve(__dirname,'node_modules')],//只从当前这个node_modules查找相应的包 alise:{//别名 \"bootstrapcss\":\"bootstrap/dist/css/bootstrap.css\" }, extensions:['js','jsx','vue','json','css'] } 2.6.2 分离文件 dev、 prod、baselet {smart} = require('webpack-merge') let base = require('./webpack.config.js') module.exports = smart(base,{ mode:'production' }) 2.7 分离打包文件2.8 跨域 方式一:在devServer中配置 devServer: { port: 8080, host: '0.0.0.0', quiet: true, proxy: { // '/api': 'http://127.0.0.1:3000', '/api': { target: 'http://127.0.0.1:3000', pathRewrite:{ '^/api': '' } }, }, before(app) { //app就是express对象 app.get('/list', function (req, res) { res.send({code: 1, msg: 'hello'}); }); } }, 方式二 : 在服务端配置(node/express) //1: npm i webpack-dev-middleware let middleDevWebpack = require('webpack-dev-middleware') let config = require('./webpack.config.js') app.use(middleDevWebpack(config)) 2.9 懒加载和热更新实时监听 热更新 devServer:{ hot:true, quite:true//安静启动 } 实时监听 watch:true, wathcOptions:{ poll:1000, aggregateTimeout:500, ignore:/note_modules/ } 3. webpack优化打包优化，可以从几个出发点点 打包体积 加载速度 打包速度 webpack自带优化 tree-sharking : import 把没用的代码自动删除掉 scope-hoisting : 作用域提升 优化网络解析时长和执行时长 添加DNS预解析 延时执行影响页面渲染的代码 优化webpack产出 优化代码重复打包 去掉不必要的import babel-preset-env 和 autoprefix 配置优化 webpack runtime文件inline 去除不必要的async语句 优化第三方依赖 lodash按需引入 webpack 知识点 hash、contenthash、chunkhash的区别 splitChunks详解 必杀技–动态链接库 多进程打包之HappyPack 提取公共代码 3.1 webpack自带优化 tree-sharking scope-hoisting 3.2 多线程打包需要用到happypack实现多线程打包 注意: 如果体积较小会使打包时间更长 第一步:下载npm install happypack --save-dev const HappyPack = require('happypack'); module.exports = { ... } 第二步: 将常用的 loader 替换为 happypack/loaderconst HappyPack = require('happypack'); module.exports = { ... module: { rules: [ test: /\\.js$/, // use: ['babel-loader?cacheDirectory'] 之前是使用这种方式直接使用 loader // 现在用下面的方式替换成 happypack/loader，并使用 id 指定创建的 HappyPack 插件 use: ['happypack/loader?id=babel'], // 排除 node_modules 目录下的文件 exclude: /node_modules/ ] } } 三、创建 HappyPack 插件module.exports = { ... module: { rules: [ test: /\\.js$/, // use: ['babel-loader?cacheDirectory'] 之前是使用这种方式直接使用 loader // 现在用下面的方式替换成 happypack/loader，并使用 id 指定创建的 HappyPack 插件 use: ['happypack/loader?id=babel'], // 排除 node_modules 目录下的文件 exclude: /node_modules/ ] }, plugins: [ ..., new HappyPack({ /* * 必须配置 */ // id 标识符，要和 rules 中指定的 id 对应起来 id: 'babel', // 需要使用的 loader，用法和 rules 中 Loader 配置一样 // 可以直接是字符串，也可以是对象形式 loaders: ['babel-loader?cacheDirectory'] }) ] } 3.3 关于语言包的打包有些包自带语言包，有时候不需要把所有的语言包跟着打包比如 moment，那么我们就需要把这个包特殊对待， 主要是通过webpack自导的IgnorePlugin src下某.js import moment from 'moment'; import 'moment/locale/zh-cn'; moment.locale('zh-cn'); let r = moment().endOf('day').fromNow(); console.log(r); webpack.config.js plugins: [ ... new webpack.IgnorePlugin(/\\.\\/locale/,/moment/), ] 3.3 不打包某个文件有些文件我们不希望打包，比如已经在cdn中引入了的文件，此时要用externals进行配置 modules:{ noParse:/jquery/, ... } plugins: [ ... new webpack.ProvidePlugin({ '$': 'jquery' }), ] //忽略打包的文件 externals:{ 'jquery': '$' } 3.4 关于css前缀的处理3.5 关于js新语法的处理3.6 关于文件拆分的处理3.7 关于别名和扩展名的处理3.8 webpack必杀技 : 动态链接库 什么是动态链接库: 用dll链接的方式提取固定的js文件，并链接这个js文件 当我们引入一个js文件的时候，这个js文件比较大，那我们是否可以单独打包，发布到cdn上，直接引用 比如 当我们想要把react打包的时候，希望将react和reactdom放到一个js文件打包的时候 不打包这两个文件，而是直接引用js的cdn路径 新建一个webpack的js配置文件 webpack.react.js var path = require('path'); let webpack = require(\"webpack\"); module.exports = { mode: 'development', entry: { react: ['react', 'react-dom'] }, output:{ filename: '_dll_[name].js', path: path.resolve(__dirname, 'dist'), library: '_dll_[name]', // \"var\" | \"assign\" | \"this\" | \"window\" | \"self\" | \"global\" | \"commonjs\" | \"commonjs2\" | \"commonjs-module\" | \"amd\" | \"amd-require\" | \"umd\" | \"umd2\" | \"jsonp\" | \"system\" // libraryTarget: 'commonjs2'//默认 var }, plugins: [ new webpack.DllPlugin({ name: '_dll_[name]', path: path.resolve(__dirname, 'dist', 'manifest.json') }) ] }; npx webpack --config webpack.react.js 此时就会生成一个manifest.json文件 最后 在webpack.prod.config.js线上配置文件中引入插件 new webpack.DllReferencePlugin({ manifest: path.resolve(__dirname, 'dist', 'manifest.json') }) 3.9 抽离公共代码块optimization: {//webpack4.0之后出现的优化项 minimizer: [new TerserPlugin({}), new OptimizeCssAssetsWebpackPlugin({})],//压缩css //缺陷 可以压缩css 但是 js压缩又出现了问题 splitChunks:{//分割代码块 cacheGroups:{//缓存组 common:{//公共的逻辑 chunks: 'initial',//从入口文件开始查找 minSize: 0,//最小分包体积 minChunks: 2,// }, vendor:{ priority: 1, test:/node_modules/, chunks: 'initial', minSize: 0, minChunks: 2 } } } }, 4. webpack打包原理webpack 构建流程Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 : 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。 确定入口：根据配置中的 entry 找出所有的入口文件。 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。 在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 实践加深理解,撸一个简易 webpack1. 定义 Compiler 类class Compiler { constructor(options) { // webpack 配置 const { entry, output } = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] } // 构建启动 run() {} // 重写 require函数,输出bundle generate() {} } 2. 解析入口文件,获取 AST我们这里使用@babel/parser,这是 babel7 的工具,来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。 // webpack.config.js const path = require('path') module.exports = { entry: './src/index.js', output: { path: path.resolve(__dirname, './dist'), filename: 'main.js' } } // const fs = require('fs') const parser = require('@babel/parser') const options = require('./webpack.config') const Parser = { getAst: path =&gt; { // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, { sourceType: 'module' }) } } class Compiler { constructor(options) { // webpack 配置 const { entry, output } = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] } // 构建启动 run() { const ast = Parser.getAst(this.entry) } // 重写 require函数,输出bundle generate() {} } new Compiler(options).run() 3. 找出所有依赖模块Babel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。 const fs = require('fs') const path = require('path') const options = require('./webpack.config') const parser = require('@babel/parser') const traverse = require('@babel/traverse').default const Parser = { getAst: path =&gt; { // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, { sourceType: 'module' }) }, getDependecies: (ast, filename) =&gt; { const dependecies = {} // 遍历所有的 import 模块,存入dependecies traverse(ast, { // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration({ node }) { const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath } }) return dependecies } } class Compiler { constructor(options) { // webpack 配置 const { entry, output } = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] } // 构建启动 run() { const { getAst, getDependecies } = Parser const ast = getAst(this.entry) const dependecies = getDependecies(ast, this.entry) } // 重写 require函数,输出bundle generate() {} } new Compiler(options).run() 4. AST 转换为 code将 AST 语法树转换为浏览器可执行代码,我们这里使用@babel/core 和 @babel/preset-env。 const fs = require('fs') const path = require('path') const options = require('./webpack.config') const parser = require('@babel/parser') const traverse = require('@babel/traverse').default const { transformFromAst } = require('@babel/core') const Parser = { getAst: path =&gt; { // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, { sourceType: 'module' }) }, getDependecies: (ast, filename) =&gt; { const dependecies = {} // 遍历所有的 import 模块,存入dependecies traverse(ast, { // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration({ node }) { const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath } }) return dependecies }, getCode: ast =&gt; { // AST转换为code const { code } = transformFromAst(ast, null, { presets: ['@babel/preset-env'] }) return code } } class Compiler { constructor(options) { // webpack 配置 const { entry, output } = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] } // 构建启动 run() { const { getAst, getDependecies, getCode } = Parser const ast = getAst(this.entry) const dependecies = getDependecies(ast, this.entry) const code = getCode(ast) } // 重写 require函数,输出bundle generate() {} } new Compiler(options).run() 5. 递归解析所有依赖项,生成依赖关系图const fs = require('fs') const path = require('path') const options = require('./webpack.config') const parser = require('@babel/parser') const traverse = require('@babel/traverse').default const { transformFromAst } = require('@babel/core') const Parser = { getAst: path =&gt; { // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, { sourceType: 'module' }) }, getDependecies: (ast, filename) =&gt; { const dependecies = {} // 遍历所有的 import 模块,存入dependecies traverse(ast, { // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration({ node }) { const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath } }) return dependecies }, getCode: ast =&gt; { // AST转换为code const { code } = transformFromAst(ast, null, { presets: ['@babel/preset-env'] }) return code } } class Compiler { constructor(options) { // webpack 配置 const { entry, output } = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] } // 构建启动 run() { // 解析入口文件 const info = this.build(this.entry) this.modules.push(info) this.modules.forEach(({ dependecies }) =&gt; { // 判断有依赖对象,递归解析所有依赖项 if (dependecies) { for (const dependency in dependecies) { this.modules.push(this.build(dependecies[dependency])) } } }) // 生成依赖关系图 const dependencyGraph = this.modules.reduce( (graph, item) =&gt; ({ ...graph, // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容 [item.filename]: { dependecies: item.dependecies, code: item.code } }), {} ) } build(filename) { const { getAst, getDependecies, getCode } = Parser const ast = getAst(filename) const dependecies = getDependecies(ast, filename) const code = getCode(ast) return { // 文件路径,可以作为每个模块的唯一标识符 filename, // 依赖对象,保存着依赖模块路径 dependecies, // 文件内容 code } } // 重写 require函数,输出bundle generate() {} } new Compiler(options).run() 6. 重写 require 函数,输出 bundleconst fs = require('fs') const path = require('path') const options = require('./webpack.config') const parser = require('@babel/parser') const traverse = require('@babel/traverse').default const { transformFromAst } = require('@babel/core') const Parser = { getAst: path =&gt; { // 读取入口文件 const content = fs.readFileSync(path, 'utf-8') // 将文件内容转为AST抽象语法树 return parser.parse(content, { sourceType: 'module' }) }, getDependecies: (ast, filename) =&gt; { const dependecies = {} // 遍历所有的 import 模块,存入dependecies traverse(ast, { // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句) ImportDeclaration({ node }) { const dirname = path.dirname(filename) // 保存依赖模块路径,之后生成依赖关系图需要用到 const filepath = './' + path.join(dirname, node.source.value) dependecies[node.source.value] = filepath } }) return dependecies }, getCode: ast =&gt; { // AST转换为code const { code } = transformFromAst(ast, null, { presets: ['@babel/preset-env'] }) return code } } class Compiler { constructor(options) { // webpack 配置 const { entry, output } = options // 入口 this.entry = entry // 出口 this.output = output // 模块 this.modules = [] } // 构建启动 run() { // 解析入口文件 const info = this.build(this.entry) this.modules.push(info) this.modules.forEach(({ dependecies }) =&gt; { // 判断有依赖对象,递归解析所有依赖项 if (dependecies) { for (const dependency in dependecies) { this.modules.push(this.build(dependecies[dependency])) } } }) // 生成依赖关系图 const dependencyGraph = this.modules.reduce( (graph, item) =&gt; ({ ...graph, // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容 [item.filename]: { dependecies: item.dependecies, code: item.code } }), {} ) this.generate(dependencyGraph) } build(filename) { const { getAst, getDependecies, getCode } = Parser const ast = getAst(filename) const dependecies = getDependecies(ast, filename) const code = getCode(ast) return { // 文件路径,可以作为每个模块的唯一标识符 filename, // 依赖对象,保存着依赖模块路径 dependecies, // 文件内容 code } } // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle generate(code) { // 输出文件路径 const filePath = path.join(this.output.path, this.output.filename) // 懵逼了吗? 没事,下一节我们捋一捋 const bundle = `(function(graph){ function require(module){ function localRequire(relativePath){ return require(graph[module].dependecies[relativePath]) } var exports = {}; (function(require,exports,code){ eval(code) })(localRequire,exports,graph[module].code); return exports; } require('${this.entry}') })(${JSON.stringify(code)})` // 把文件内容写入到文件系统 fs.writeFileSync(filePath, bundle, 'utf-8') } } new Compiler(options).run() 7. 看完这节,彻底搞懂 bundle 实现我们通过下面的例子来进行讲解,先死亡凝视 30 秒 ;(function(graph) { function require(moduleId) { function localRequire(relativePath) { return require(graph[moduleId].dependecies[relativePath]) } var exports = {} ;(function(require, exports, code) { eval(code) })(localRequire, exports, graph[moduleId].code) return exports } require('./src/index.js') })({ './src/index.js': { dependecies: { './hello.js': './src/hello.js' }, code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));' }, './src/hello.js': { dependecies: {}, code: '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n return \"hello \".concat(name);\\n}' } }) step 1 : 从入口文件开始执行// 定义一个立即执行函数,传入生成的依赖关系图 ;(function(graph) { // 重写require函数 function require(moduleId) { console.log(moduleId) // ./src/index.js } // 从入口文件开始执行 require('./src/index.js') })({ './src/index.js': { dependecies: { './hello.js': './src/hello.js' }, code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));' }, './src/hello.js': { dependecies: {}, code: '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n return \"hello \".concat(name);\\n}' } }) step 2 : 使用 eval 执行代码// 定义一个立即执行函数,传入生成的依赖关系图 ;(function(graph) { // 重写require函数 function require(moduleId) { ;(function(code) { console.log(code) // \"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\")); eval(code) // Uncaught TypeError: Cannot read property 'code' of undefined })(graph[moduleId].code) } // 从入口文件开始执行 require('./src/index.js') })({ './src/index.js': { dependecies: { './hello.js': './src/hello.js' }, code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));' }, './src/hello.js': { dependecies: {}, code: '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n return \"hello \".concat(name);\\n}' } }) 可以看到,我们在执行”./src/index.js”文件代码的时候报错了,这是因为 index.js 里引用依赖 hello.js,而我们没有对依赖进行处理,接下来我们对依赖引用进行处理。 step 3 : 依赖对象寻址映射,获取 exports 对象// 定义一个立即执行函数,传入生成的依赖关系图 ;(function(graph) { // 重写require函数 function require(moduleId) { // 找到对应moduleId的依赖对象,调用require函数,eval执行,拿到exports对象 function localRequire(relativePath) { return require(graph[moduleId].dependecies[relativePath]) // {__esModule: true, say: ƒ say(name)} } // 定义exports对象 var exports = {} ;(function(require, exports, code) { // commonjs语法使用module.exports暴露实现,我们传入的exports对象会捕获依赖对象(hello.js)暴露的实现(exports.say = say)并写入 eval(code) })(localRequire, exports, graph[moduleId].code) // 暴露exports对象,即暴露依赖对象对应的实现 return exports } // 从入口文件开始执行 require('./src/index.js') })({ './src/index.js': { dependecies: { './hello.js': './src/hello.js' }, code: '\"use strict\";\\n\\nvar _hello = require(\"./hello.js\");\\n\\ndocument.write((0, _hello.say)(\"webpack\"));' }, './src/hello.js': { dependecies: {}, code: '\"use strict\";\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n value: true\\n});\\nexports.say = say;\\n\\nfunction say(name) {\\n return \"hello \".concat(name);\\n}' } }) 这下应该明白了吧 ~ 可以直接复制上面代码到控制台输出哦~ 完整代码地址戳我 👈 总结 Webpack 是一个庞大的 Node.js 应用,如果你阅读过它的源码,你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节,只需了解其整体架构和部分细节即可。 对 Webpack 的使用者来说,它是一个简单强大的工具； 对 Webpack 的开发者来说,它是一个扩展性的高系统。 Webpack 之所以能成功,在于它把复杂的实现隐藏了起来,给用户暴露出的只是一个简单的工具,让用户能快速达成目的。 同时整体架构设计合理,扩展性高,开发扩展难度不高,通过社区补足了大量缺失的功能,让 Webpack 几乎能胜任任何场景。","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://promisefine.github.io/tags/Webpack/"}],"author":"Doney"},{"title":"操作系统的发展史","slug":"linux09","date":"2019-12-08T06:32:02.000Z","updated":"2021-07-16T06:34:47.677Z","comments":true,"path":"posts/5ec3b9ec.html","link":"","permalink":"https://promisefine.github.io/posts/5ec3b9ec.html","excerpt":"","text":"操作系统的发展史（科普章节）目标 了解操作系统的发展历史 知道 Linux 内核及发行版的区别 知道 Linux 的应用领域 01. 操作系统的发展历史1.1 Unix1965 年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑 为了解决数量不够用的问题 1965 年左后由 贝尔实验室 加入了 麻省理工学院 以及 通用电气 合作的计划 —— 该计划要建立一套 多使用者(multi－user)**、多任务(multi－processor)、多层次(multi－level)** 的 MULTICS 操作系统，想让大型主机支持 300 台终端 1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969 年从这个项目中退出的 Ken Thompson 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 “星际旅行（Space Travel）” 游戏，在 8 月份左右趁着其妻子探亲的时间，用了 1 个月的时间，使用汇编写出了 Unix 操作系统的原型 1970 年，美国贝尔实验室的 Ken Thompson，以 BCPL 语言为基础，设计出很简单且很接近硬件的 B 语言（取BCPL的首字母），并且他用 B 语言 写了第一个 UNIX 操作系统 1971 年，同样酷爱 “星际旅行（Space Travel）” 的 Dennis M.Ritchie 为了能早点儿玩上游戏，加入了 Thompson 的开发项目，合作开发 UNIX，他的主要工作是改造 B 语言，因为B 语言 的跨平台性较差 1972 年，Dennis M.Ritchie 在 B 语言 的基础上最终设计出了一种新的语言，他取了 BCPL 的第二个字母作为这种语言的名字，这就是 C 语言 1973 年初，C 语言的主体完成，Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix 操作系统 C 语言 在把 UNIX 移植到其他类型的计算机上使用时，C 语言强大的移植性（Portability）在此显现 机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在 Alpha，SPARC 和 ARM 等机器上运行 而 C 语言程序则可以使用在任意架构的处理器上，只要那种架构的处理器具有对应的 C 语言编译器和库，然后将 C 源代码编译、连接成目标二进制文件之后即可运行 1.2 Minix 因为 AT&amp;T（通用电气） 的政策改变，在 Version 7 Unix 推出之后，发布新的使用条款，将 UNIX 源代码私有化，在大学中不再能使用 UNIX 源代码 Andrew S. Tanenbaum（塔能鲍姆） 教授为了能 在课堂上教授学生操作系统运作的细节，决定在不使用任何 AT&amp;T 的源代码前提下，自行开发与 UNIX 兼容的操作系统，以避免版权上的争议 以 小型 UNIX（mini-UNIX）之意，将它称为 MINIX 1.3 Linux 1991 年 林纳斯（Linus） 就读于赫尔辛基大学期间，对 Unix 产生浓厚兴趣，尝试着在Minix 上做一些开发工作 因为 Minix 只是教学使用，因此功能并不强，林纳斯 经常要用他的终端 仿真器（Terminal Emulator） 去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这些在后来成为了 Linux 第一个内核的雏形，当时，他年仅 21 岁！ 林纳斯 利用 GNU 的 bash 当做开发环境，gcc 当做编译工具，编写了 Linux 内核，一开始 Linux 并不能兼容 Unix 即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致 一开始 Linux 只适用于 386，后来经过全世界的网友的帮助，最终能够兼容多种硬件 02. Linux 内核及发行版2.1 Linux 内核版本 内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层 Linux 内核版本又分为 稳定版 和 开发版，两种版本是相互关联，相互循环 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序 开发版：由于要试验各种解决方案，所以变化很快 内核源码网址：http://www.kernel.org 所有来自全世界的对 Linux 源码的修改最终都会汇总到这个网站，由 Linus 领导的开源社区对其进行甄别和修改最终决定是否进入到 Linux 主线内核源码中 2.2 Linux 发行版本 Linux 发行版（也被叫做 GNU/Linux 发行版）通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件 常见的发行版本如下： Ubuntu Redhat Fedora openSUSE Linux Mint Debian Manjaro Mageia CentOS Arch 十大 Linux 服务器发行版排行榜：http://os.51cto.com/art/201612/526126.htm 在几乎每一份与 Linux 有关的榜单上，基于 Debian 的 Ubuntu 都占有一席之位。Canonical 的Ubuntu 胜过其他所有的 Linux 服务器发行版 ―― 从简单安装、出色的硬件发现，到世界级的商业支持，Ubuntu确立了难以企及的严格标准 03. Linux 的应用领域3.1 服务器领域 Linux 在服务器领域的应用是其重要分支 Linux 免费、稳定、高效等特点在这里得到了很好的体现 早期因为维护、运行等原因同样受到了很大的限制 近些年来 Linux 服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛 3.2 嵌入式领域 近些年来 Linux 在嵌入式领域的应用得到了飞速的提高 Linux 运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百 KB 等特点，使其近些年来在嵌入式领域的应用得到非常大的提高 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域，得到了 Google、三星、摩托罗拉、NEC 等公司的大力推广 3.3 个人桌面领域 此领域是传统 Linux 应用最薄弱的环节 传统 Linux 由于界面简单、操作复杂、应用软件少的缺点，一直被 Windows 所压制 近些年来随着 Ubuntu、Fedora 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，Linux 在个人桌面领域的占有率在逐渐的提高","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"操作系统","slug":"linux08","date":"2019-12-08T05:24:57.000Z","updated":"2021-07-16T06:27:09.110Z","comments":true,"path":"posts/29c4897a.html","link":"","permalink":"https://promisefine.github.io/posts/29c4897a.html","excerpt":"","text":"操作系统目标 了解操作系统及作用 1. 操作系统（Operation System，OS） 没有安装操作系统的计算机，通常被称为 裸机 如果想在 裸机 上运行自己所编写的程序，就必须用机器语言书写程序 如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序 1.1 操作系统的作用 是现代计算机系统中 最基本和最重要 的系统软件 是 配置在计算机硬件上的第一层软件，是对硬件系统的首次扩展 主要作用是管理好硬件设备，并为用户和应用程序提供一个简单的接口，以便于使用 而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持 1.2 不同应用领域的主流操作系统 桌面操作系统 服务器操作系统 嵌入式操作系统 移动设备操作系统 1&gt; 桌面操作系统 Windows 系列 用户群体大 macOS 适合于开发人员 Linux 应用软件少 2&gt; 服务器操作系统 Linux 安全、稳定、免费 占有率高 Windows Server 付费 占有率低 3&gt; 嵌入式操作系统 Linux 4&gt; 移动设备操作系统 iOS Android（基于 Linux） 1.3 虚拟机虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统 虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"远程管理常用命令","slug":"linux07","date":"2019-12-07T06:21:46.000Z","updated":"2021-07-16T06:30:30.520Z","comments":true,"path":"posts/b97b94eb.html","link":"","permalink":"https://promisefine.github.io/posts/b97b94eb.html","excerpt":"","text":"远程管理常用命令目标 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登录和复制文件 ssh scp 01. 关机/重启 序号 命令 对应英文 作用 01 shutdown 选项 时间 shutdown 关机／重新启动 1.1 shutdown shutdown 命令可以 安全 关闭 或者 重新启动系统 选项 含义 -r 重新启动 提示： 不指定选项和参数，默认表示 1 分钟之后 关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 常用命令示例 # 重新启动操作系统，其中 now 表示现在 $ shutdown -r now # 立刻关机，其中 now 表示现在 $ shutdown now # 系统在今天的 20:25 会关机 $ shutdown 20:25 # 系统再过十分钟后自动关机 $ shutdown +10 # 取消之前指定的关机计划 $ shutdown -c 02. 查看或配置网卡信息 序号 命令 对应英文 作用 01 ifconfig configure a network interface 查看/配置计算机当前的网卡配置信息 02 ping ip地址 ping 检测到目标 ip地址 的连接是否正常 2.1 网卡 和 IP 地址网卡 网卡是一个专门负责网络通讯的硬件设备 IP 地址是设置在网卡上的地址信息 我们可以把 电脑 比作 电话，网卡 相当于 SIM 卡，IP 地址 相当于 电话号码 IP 地址 每台联网的电脑上都有 IP 地址，是保证电脑之间正常通讯的重要设置 注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯 提示：有关 IP 地址的详细内容，在就业班会详细讲解！ 2.2 ifconfig ifconfig 可以查看／配置计算机当前的网卡配置信息 # 查看网卡配置信息 $ ifconfig # 查看网卡对应的 IP 地址 $ ifconfig | grep inet 提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 2.3 ping# 检测到目标主机是否连接正常 $ ping IP地址 # 检测本地网卡工作正常 $ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢 ping 的工作原理与潜水艇的声纳相似，ping 这个命令就是取自 声纳的声音 网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着 原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在 提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 CTRL + C 03. 远程登录和复制文件 序号 命令 对应英文 作用 01 ssh 用户名@ip secure shell 关机／重新启动 02 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 secure copy 远程复制文件 3.1 ssh 基础（重点）在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上 SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 SSH 是目前较可靠，专为远程登录会话和其他网络服务 提供安全性的协议 利用 SSH 协议 可以有效防止远程管理过程中的信息泄露 通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度 1) 域名 和 端口号域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是 IP 地址 的别名，方便用户记忆 端口号 IP 地址：通过 IP 地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 SSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略 常见服务端口号列表： 序号 服务 端口号 01 SSH 服务器 22 02 Web 服务器 80 03 HTTPS 443 04 FTP 服务器 21 提示：有关 端口号的详细内容，在就业班会详细讲解！ 2) SSH 客户端的简单使用ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 提示： 使用 exit 退出当前用户的登录 注意： ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可 提示： 在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 3) Windows 下 SSH 客户端的安装 Putty http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html XShell http://xshellcn.com 建议从官方网站下载正式的安装程序 3.2 scp（掌握） scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 # 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py # 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径 scp -P port 01.py user@remote:Desktop/01.py # 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py scp -P port user@remote:Desktop/01.py 01.py # 加上 -r 选项可以传送文件夹 # 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop scp -r demo user@remote:Desktop # 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹 scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 注意： scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输 FileZilla 官方网站：https://www.filezilla.cn/download/client FileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21 3.3 SSH 高级（知道） 免密码登录 配置别名 提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 1）免密码登录步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 非对称加密算法 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 2) 配置别名每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： Host mac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"系统信息相关命令","slug":"linux06","date":"2019-12-06T06:19:36.000Z","updated":"2021-07-16T06:30:35.183Z","comments":true,"path":"posts/ce7ca47d.html","link":"","permalink":"https://promisefine.github.io/posts/ce7ca47d.html","excerpt":"","text":"系统信息相关命令 本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况 本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 01. 时间和日期 序号 命令 作用 01 date 查看系统时间 02 cal calendar 查看日历，-y 选项可以查看一年的日历 02. 磁盘信息 序号 命令 作用 01 df -h disk free 显示磁盘剩余空间 02 du -h [目录名] disk usage 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 03. 进程信息 所谓 进程，通俗地说就是 当前正在执行的一个程序 序号 命令 作用 01 ps aux process status 查看进程的详细状况 02 top 动态显示运行中的进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃 要退出 top 可以直接输入 q","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"用户权限相关命令","slug":"linux05","date":"2019-12-05T05:16:45.000Z","updated":"2021-07-16T06:18:32.800Z","comments":true,"path":"posts/5775f5c7.html","link":"","permalink":"https://promisefine.github.io/posts/5775f5c7.html","excerpt":"","text":"用户权限相关命令目标 用户 和 权限 的基本概念 用户管理 终端命令 组管理 终端命令 修改权限 终端命令 01. 用户 和 权限 的基本概念1.1 基本概念 用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限 对 文件／目录 的权限包括： 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 excute x 1 1.2 组 为了方便用户管理，提出了 组 的概念 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 1.3 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 权限，第 1 个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下 文件／目录 的拥有者通常都是当前用户 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 1.4 chmod 简单使用（重要） chmod 可以修改 用户／组 对 文件／目录 的权限 命令格式如下： chmod +/-rwx 文件名|目录名 提示：以上方式会一次性修改 拥有者 / 组 权限，有关 chmod 的高级用法，后续会讲 1.5 超级用户 Linux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限 在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统 在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户” sudo su 是 substitute user 的缩写，表示 使用另一个用户的身份 sudo 命令用来以其他身份来执行命令，预设的身份为 root 用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码 若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员 02. 组管理 终端命令 提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行 序号 命令 作用 01 groupadd 组名 添加组 02 groupdel 组名 删除组 03 cat /etc/group 确认组信息 04 chgrp -R 组名 文件/目录名 递归修改文件/目录的所属组 提示： 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 演练目标 在 python 用户的桌面文件夹下创建 Python学习 目录 新建 dev 组 将 Python学习 目录的组修改为 dev 03. 用户管理 终端命令 提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行 3.1 创建用户／设置密码／删除用户 序号 命令 作用 说明 01 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组 02 passwd 用户名 设置用户密码 如果是普通用户，直接用 passwd 可以修改自己的账户密码 03 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 04 cat /etc/passwd | grep 用户名 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd 文件中 提示： 创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建 创建用户时，默认会创建一个和用户名同名的组名 用户信息保存在 /etc/passwd 文件中 3.2 查看用户信息 序号 命令 作用 01 id [用户名] 查看用户 UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 passwd 文件/etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名或本地帐号 家目录 登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash usermod usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下： 主组：通常在新建用户时指定，在 etc/passwd 的第 4 列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限 提示：设置了用户的附加组之后，需要重新登录才能生效！ # 修改用户的主组（passwd 中的 GID） usermod -g 组 用户名 # 修改用户的附加组 usermod -G 组 用户名 # 修改用户登录 Shell usermod -s /bin/bash 用户名 注意：默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中 usermod -G sudo 用户名 which（重要） 提示 /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 which 命令可以查看执行命令所在位置，例如： which ls # 输出 # /bin/ls which useradd # 输出 # /usr/sbin/useradd bin 和 sbin 在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin /bin（binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin（user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 提示： cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置 3.3 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 02 exit 退出当前登录账户 su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全 04. 修改文件权限 序号 命令 作用 01 chown 修改拥有者 02 chgrp 修改组 03 chmod 修改权限 命令格式如下： # 修改文件|目录的拥有者 chown 用户名 文件名|目录名 # 递归修改文件|目录的组 chgrp -R 组名 文件名|目录名 # 递归修改文件权限 chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限 # 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他 chmod +/-rwx 文件名|目录名 常见数字组合有（u表示用户／g表示组／o表示其他）： 777 ===&gt; u=rwx,g=rwx,o=rwx 755 ===&gt; u=rwx,g=rx,o=rx 644 ===&gt; u=rw,g=r,o=r chmod 演练目标 将 01.py 的权限修改为 u=rwx,g=rx,o=r 将 123.txt 的权限修改为 u=rw,g=r,o=- 将 test 目录以及目录下的 所有 文件权限修改为 u=rwx,g=rwx,o=rx","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"其他命令","slug":"linux04","date":"2019-12-04T07:33:15.000Z","updated":"2021-07-16T06:15:58.131Z","comments":true,"path":"posts/2072c551.html","link":"","permalink":"https://promisefine.github.io/posts/2072c551.html","excerpt":"","text":"其他命令目标 查找文件 find 软链接 ln 打包和压缩 tar 软件安装 apt-get 01. 查找文件 find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 序号 命令 作用 01 find [路径] -name “*.py” 查找指定路径下扩展名是 .py 的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前学习的通配符，在使用 find 命令时同时可用 有关 find 的高级使用，在就业班会讲 演练目标 搜索桌面目录下，文件名包含 1 的文件 find -name \"*1*\" 搜索桌面目录下，所有以 .txt 为扩展名的文件 find -name \"*.txt\" 搜索桌面目录下，以数字 1 开头的文件 find -name \"1*\" 02. 软链接 序号 命令 作用 01 ln -s 被链接的源文件 链接文件 建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式 注意： 没有 -s 选项建立的是一个 硬链接文件 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 演练目标 将桌面目录下的 01.py 移动到 demo/b/c 目录下 在桌面目录下新建 01.py 的 软链接 FirstPython 分别使用 相对路径 和 绝对路径 建立 FirstPython 的软链接 将 FirstPython 移动到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别 硬链接简介（知道） 在使用 ln 创建链接时，如果没有 -s 选项，会创建一个 硬链接，而不是软链接 硬链接演练 在 ~/Desktop/demo 目录下建立 ~/Desktop/demo/b/c/01.py 的硬链接 01_hard 使用 ls -l 查看文件的硬链接数（硬链接——有多少种方式可以访问文件或者目录） 删除 ~/Desktop/demo/b/c/01.py，并且使用 tree 来确认 demo 目录下的三个链接文件 在 Linux 中，文件名 和 文件的数据 是分开存储的 提示： 在 Linux 中，只有文件的 硬链接数 == 0 才会被删除 使用 ls -l 可以查看一个文件的硬链接的数量 在日常工作中，几乎不会建立文件的硬链接，知道即可 03. 打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 Windows 常用 rar Mac 常用 zip Linux 常用 tar.gz 3.1 打包 ／ 解包 tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar 的命令格式如下： # 打包文件 tar -cvf 打包文件.tar 被打包的文件／路径... # 解包文件 tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后 注意：f 选项必须放在最后，其他选项顺序可以随意 打包解包演练 删除桌面下的所有内容 在桌面下新建三个空白文件 01.py、02.py、03.py 将这三个文件打一个 py.tar 的包 新建 tar 目录，并且将 py.tar 移动到 tar 目录下 解包 py.tar 3.2 压缩／解压缩1) gzip tar 与 gzip 命令结合可以使用实现文件 打包和压缩 tar 只负责打包文件，但不压缩 用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能 命令格式如下： # 压缩文件 tar -zcvf 打包文件.tar.gz 被压缩的文件／路径... # 解压缩文件 tar -zxvf 打包文件.tar.gz # 解压缩到指定路径 tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 2) bzip2(two) tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样） tar 只负责打包文件，但不压缩， 用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能 命令格式如下： # 压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径... # 解压缩文件 tar -jxvf 打包文件.tar.bz2 04. 软件安装4.1 通过 apt 安装／卸载软件 apt 是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具 可以在终端中方便的 安装／卸载／更新软件包 # 1. 安装软件 $ sudo apt install 软件包 # 2. 卸载软件 $ sudo apt remove 软件名 # 3. 更新已安装的包 $ sudo apt upgrade 安装演练# 一个小火车提示 $ sudo apt install sl # 一个比较漂亮的查看当前进程排名的软件 $ sudo apt install htop 4.2 配置软件源 如果希望在 ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载／安装服务 提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了 所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"文件和目录常用命令","slug":"linux03","date":"2019-12-03T06:08:55.000Z","updated":"2021-07-16T06:11:23.224Z","comments":true,"path":"posts/be1650f2.html","link":"","permalink":"https://promisefine.github.io/posts/be1650f2.html","excerpt":"","text":"文件和目录常用命令目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch rm mkdir 拷贝和移动文件 cp mv 查看文件内容 cat more grep 其他 echo 重定向 &gt; 和 &gt;&gt; 管道 | 01. 查看目录内容1.1 终端实用技巧1&gt; 自动补全 在敲出 文件／目录／命令 的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 2&gt; 曾经使用过的命令 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c 1.2 ls 命令说明 ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS 下的 dir 命令 Linux 下文件和目录的特点 Linux 文件 或者 目录 名称最长可以有 256 个字符 以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示 . 代表当前目录 .. 代表上一级目录 1.3 ls 常用选项 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 计算机中文件大小的表示方式（科普） 单位 英文 含义 字节 B（Byte） 在计算机中作为一个数字单元，一般为 8 位二进制数 千 K（Kibibyte） 1 KB = 1024 B，千字节 （1024 = 2 ** 10） 兆 M（Mebibyte） 1 MB = 1024 KB，百万字节 千兆 G（Gigabyte） 1 GB = 1024 MB，十亿字节，千兆字节 太 T（Terabyte） 1 TB = 1024 GB，万亿字节，太字节 拍 P（Petabyte） 1 PB = 1024 TB，千万亿字节，拍字节 艾 E（Exabyte） 1 EB = 1024 PB，百亿亿字节，艾字节 泽 Z（Zettabyte） 1 ZB = 1024 EB，十万亿亿字节，泽字节 尧 Y（Yottabyte） 1 YB = 1024 ZB，一亿亿亿字节，尧字节 1.4 ls 通配符的使用 通配符 含义 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 02. 切换目录2.1 cd cd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 命令 含义 cd 切换到当前用户的主目录(/home/用户目录) cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 2.2 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~**，表示相对 **当前目录 所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~**，表示从 **根目录/家目录 开始的具体目录位置 03. 创建和删除操作3.1 touch 创建文件或修改文件时间 如果文件 不存在，可以创建一个空白文件 如果文件 已经存在，可以修改文件的末次修改日期 3.2 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 3.3 rm 删除文件或目录 使用 rm 命令要小心，因为文件删除后不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹 时必须加此参数 04. 拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或者目录／文件或者目录重命名 4.1 tree tree 命令可以以树状图列出文件目录结构 选项 含义 -d 只显示目录 4.2 cp cp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中，相当于 DOS 下的 copy 命令 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 4.3 mv mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名 选项 含义 -i 覆盖文件前提示 05. 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本 文件名 grep 搜索文本文件内容 5.1 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能 cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux 中还有一个 nl 的命令和 cat -b 的效果等价 5.2 more more 命令可以用于分屏显示文件内容，每次只显示一页内容 适合于 查看内容较多的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 5.3 grep Linux 系统中 grep 命令是一种强大的文本搜索工具 grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 ke$ 行尾，搜寻以 ke 结束的行 06. 其他6.1 echo 文字内容 echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 6.2 重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件 将本应显示在终端上的内容 输出／追加 到指定文件中 其中 &gt; 表示输出，会覆盖文件原有的内容 &gt;&gt; 表示追加，会将内容追加到已有文件的末尾 6.3 管道 | Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"Linux 终端命令格式","slug":"linux02","date":"2019-12-03T03:54:11.000Z","updated":"2021-07-16T06:05:13.538Z","comments":true,"path":"posts/c9116064.html","link":"","permalink":"https://promisefine.github.io/posts/c9116064.html","excerpt":"","text":"Linux 终端命令格式目标 了解终端命令格式 知道如何查阅终端命令帮助信息 01. 终端命令格式command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]：选项，可用来对命令进行控制，也可以省略 parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息（知道） 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索 2.1 --helpcommand --help 说明： 显示 command 命令的帮助信息 2.2 manman command 说明： 查阅 command 命令的使用手册 man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"常用 Linux 命令的基本使用","slug":"linux01","date":"2019-12-02T05:59:45.000Z","updated":"2021-07-16T06:04:26.718Z","comments":true,"path":"posts/501831de.html","link":"","permalink":"https://promisefine.github.io/posts/501831de.html","excerpt":"","text":"常用 Linux 命令的基本使用目标 理解学习 Linux 终端命令的原因 常用 Linux 命令体验 01. 学习 Linux 终端命令的原因 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成 在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令 Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已 学习终端命令的技巧： 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以 02. 常用 Linux 命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print work directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 小技巧 ctrl + shift + = 放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 03. 自动补全 在敲出 文件／目录／命令 的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 小技巧 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"}],"author":"Doney"},{"title":"算法","slug":"algorithm","date":"2019-11-29T02:01:45.000Z","updated":"2021-07-16T03:23:28.310Z","comments":true,"path":"posts/9505ccb9.html","link":"","permalink":"https://promisefine.github.io/posts/9505ccb9.html","excerpt":"","text":"复杂度// 大O算法就是算法执⾏所需要的执⾏次数，和数据量的关系(时间复杂度),占⽤额外空间和数据量的关系(空间复杂度) O(1) : 常数复杂度 (和数据量⽆关) O(logn) :对数复杂度 (⼆分) O(n) : 线性时间复杂度 （数组遍历⼀次） O(n*logn) : 线性对数 （遍历+⼆分） O(n^2) : 平⽅ 两层遍历 O(2^n) : 指数 递归 O(n!) : 阶乘 冒泡排序function bubleSort(arr) { var len = arr.length for (let outer = len; outer &gt;= 2; outer--) { for (let inner = 0; inner &lt;= outer - 1; inner++) { if (arr[inner] &gt; arr[inner + 1]) { [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]] } } } return arr } console.log(bubleSort([4, 3, 6, 1, 9, 6, 2])) 插入排序function insertSort(arr) { for (let i = 1; i &lt; arr.length; i++) { //外循环从1开始，默认arr[0]是有序段 for (let j = i; j &gt; 0; j--) { //j = i,将arr[j]依次插⼊有序段中 if (arr[j] &lt; arr[j - 1]) { [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; } else { break; } } } return arr; } console.log(insertSort([11, 4, 3, 6, 1, 9, 7, 2, 0])) 快速排序function quickSort(arr) { if (arr.length &lt;= 1) { return arr; //递归出⼝ } var left = [], right = [], current = arr.splice(0, 1); //注意splice后，数组⻓度少了⼀个 for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; current) { left.push(arr[i]) //放在左边 } else { right.push(arr[i]) //放在右边 } } return quickSort(left).concat(current, quickSort(right)); //递归 } 数组扁平化Array.prototype.flat = function () { var arr = []; this.forEach((item, idx) =&gt; { if (Array.isArray(item)) { arr = arr.concat(item.flat()); //递归去处理数组元素 } else { arr.push(item) //⾮数组直接push进去 } }) return arr; //递归出⼝ } arr = [1, 2, 3, [4, 5, [6, 7, [8, 9]]], [10, 11] ] console.log(arr.flat()) 查找算法// 循环的二分查找 function binarySearch(arr, target) { var low = 0, high = arr.length - 1, mid; while (low &lt;= high) { mid = Math.floor((low + high) / 2); if (target === arr[mid]) { return `找到了${target},在第${mid + 1}个` } if (target &gt; arr[mid]) { low = mid + 1; } else if (target &lt; arr[mid]) { high = mid - 1; } } return -1 } console.log(binarySearch([1, 2, 3, 4, 5, 7, 9, 11, 14, 16, 17, 22, 33, 55, 65], 4)) // 递归的二分查找 function binarySearch1(arr, target, low = 0, high = arr.length - 1) { const n = Math.floor((low + high) / 2); const cur = arr[n]; if (cur === target) { return `找到了${target},在第${n+1}个`; } else if (cur &gt; target) { return binarySearch1(arr, target, low, n - 1); } else if (cur &lt; target) { return binarySearch1(arr, target, n + 1, high); } return -1; } 数据结构栈class Stack { constructor() { this.items = [] } push(item) { this.items.push(item) } pop() { return this.items.pop() } size() { return this.items.length } clear() { this.items = [] } } 索引: O(n) 搜索: O(n) 插⼊: O(1) 移除: O(1) // 经典案例： 括号匹配，html标签匹配，进制转换 function isBalance(symbol) { const stack = new Stack() const left = '{(' const right = '})' let popValue let tag = true const match = function (popValue, current) { if (left.indexOf(popValue) !== right.indexOf(current)) { tag = false } } for (let i = 0; i &lt; symbol.length; i++) { if (left.includes(symbol[i])) { stack.push(symbol[i]) } else if (right.includes(symbol[i])) { popValue = stack.pop() match(popValue, symbol[i]) } } return tag } console.log(isBalance('{{(({}))}}')) console.log(isBalance('{{(({})}}')) 链表 class Node { constructor(element) { this.element = element this.next = null } } class LinkedList { constructor() { this.head = null this.current this.length = 0 } append(element) { const node = new Node(element) if (this.head === null) { // 插⼊第⼀个链表 this.head = node } else { this.current = this.head while (this.current.next) { // 找到最后⼀个节点 this.current = this.current.next } this.current.next = node } this.length++ } // 移除指定位置元素 removeAt(position) { if (position &gt; -1 &amp;&amp; position &lt; this.length) { let previous let index = 0 if (position === 0) { // 如果是第⼀个链表的话, 特殊对待 this.head = this.head.next } else { 开课吧web全栈架构师 this.current = this.head while (index &lt; position) { // 循环找到当前要删除元素的位置 previous = this.current this.current = this.current.next index++ } previous.next = this.current.next } this.length-- } } // 在指定位置加⼊元素 insert(position, element) { const node = new Node(element) let index = 0 let current, previous if (position &gt; -1 &amp;&amp; position &lt; this.length + 1) { if (position === 0) { // 在链表最前插⼊元素 current = this.head this.head = node this.head.next = current } else { current = this.head while (index &lt; position) { // 同 removeAt 逻辑, 找到⽬标位置 previous = current current = current.next index++ } previous.next = node // 在⽬标位置插⼊相应元素 node.next = current } this.length++ } } // 链表中是否含有某个元素, 如果有的话返回相应位置, ⽆的话返回 -1 indexOf(element) { let index = 0 this.current = this.head while (index &lt; this.length) { if (this.current.element === element) { return index } this.current = this.current.next index++ } return -1 } // 移除某元素 remove(element) { const position = this.indexOf(element) this.removeAt(position) } // 获取⼤⼩ size() { return this.length } // 获取最开头的链表 getHead() { return this.head } // 是否为空 isEmpty() { return this.length === 0 } // 打印链表元素 log() { this.current = this.head let str = this.current.element while (this.current.next) { this.current = this.current.next str = str + ' ' + this.current.element } console.log(str) return str } } // 测试⽤例 var linkedList = new LinkedList() linkedList.append(5) linkedList.append(10) linkedList.append(15) linkedList.append(20) linkedList.log() // '5 10 15 20' linkedList.removeAt(1) linkedList.log() // '5 15 20' linkedList.insert(1, 10) linkedList.log() 集合 Set和Mapnew Set() new WeekSet() new Map() new WeekMap() class Set { constructor() { this.items = {} } has(value) { return this.items.hasOwnProperty(value) } add(value) { if (!this.has(value)) { this.items[value] = value return true } return false } remove(value) { if (this.has(value)) { delete this.items[value] return true } return false } get size() { return Object.keys(this.items).length } get values() { return Object.keys(this.items) } } const set = new Set() set.add(1) console.log(set.values) // [\"1\"] console.log(set.has(1)) // true console.log(set.size) // 1 set.add(2) console.log(set.values) // [\"1\", \"2\"] console.log(set.has(2)) // true console.log(set.size) // 2 set.remove(1) console.log(set.values) // [\"2\"] set.remove(2) console.log(set.values) // [] 哈希表 名称 散列函数 散列值 散列表 John 74+111+104+110 399 [399] [john@qq.com] class HashTable { constructor() { this.items = {} } put(key, value) { const hash = this.keyToHash(key) this.items[hash] = value } get(key) { return this.items[this.keyToHash(key)] } remove(key) { delete(this.items[this.keyToHash(key)]) } keyToHash(key) { let hash = 0 for (let i = 0; i &lt; key.length; i++) { hash += key.charCodeAt(i) } hash = hash % 37 // 为了避免 hash 的值过⼤ return hash } } let ht = new HashTable() ht.put('name', 'xxx') ht.put('age', '6') console.log(ht.get('name')) ht.remove('name') console.log(ht.get('name')) 算法技巧动态规划// 例如斐波那契 // 递归 function fib(n) { if (n == 1 || n == 2) return 1 return fib(n - 1) + fib(n - 2) } // 动归 解决子问题重复 function fib(n) { let memo = [] return helper(memo, n) } function helper(memo, n) { if (n == 1 || n == 2) { // 前两个 return 1 } // 如果有缓存，直接返回 if (memo[n]) return memo[n]; // 没缓存 memo[n] = helper(memo, n - 1) + helper(memo, n - 2) return memo[n] } // 动归解决 function fib(n) { let dp = [] dp[1] = dp[2] = 1 for (let i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n] } // 假如有1,5,10,20,50,100人民币 4 [1, 1, 1, 1] // 需 4 个 1 5 [5] // 需 1 个 5 36 [20, 10, 5, 1] // 需 20、10、5、1各⼀个 class Change { constructor(changeType) { this.changeType = changeType this.cache = {} } makeChange(amount) { let min = [] if (!amount) { return [] } if (this.cache[amount]) { // 读缓存 return this.cache[amount] } for (let i = 0; i &lt; this.changeType.length; i++) { const leftAmount = amount - this.changeType[i] let newMin if (leftAmount &gt;= 0) { newMin = this.makeChange(leftAmount) // 这⼀句是动态规划的提现 } if (leftAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length - 1 || !min.length)) { // 如果存在更⼩的找零硬币数, 则执⾏后⾯语句 min = [this.changeType[i]].concat(newMin) } } return this.cache[amount] = min } } const change = new Change([1, 5, 10, 20, 50, 100]) console.log(change.makeChange(2)) console.log(change.makeChange(5)) console.log(change.makeChange(13)) console.log(change.makeChange(35)) console.log(change.makeChange(135)) 贪心算法 // 贪⼼ 先找最大面值，超了再找其他的 class Change { constructor(changeType) { this.changeType = changeType.sort((r1, r2) =&gt; r2 - r1) } makeChange(amount) { const arr = [] for (let i = 0; i &lt; this.changeType.length; i++) { while (amount - this.changeType[i] &gt;= 0) { arr.push(this.changeType[i]) amount = amount - this.changeType[i] } } return arr } } const change = new Change([1, 5, 10, 20, 50, 100]) console.log(change.makeChange(36)) console.log(change.makeChange(136)) console.log('-'.repeat(100)) // 有时贪心算法不一定准确，求的最大近似解 const change1 = new Change([1, 3, 4]) console.log(change1.makeChange(6)) // 其实[3, 3]最好","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"前端性能优化","slug":"optimization","date":"2019-11-16T00:10:03.000Z","updated":"2021-07-16T03:23:59.279Z","comments":true,"path":"posts/604c45ad.html","link":"","permalink":"https://promisefine.github.io/posts/604c45ad.html","excerpt":"","text":"前端性能优化：从输入URL到页面加载完成，发生了什么 1. ⽤户输⼊www.baidu.com 2. 浏览器通过DNS，把url解析为IP 3. 和IP地址建⽴TCP链接 发送HTTP请求 4. 服务器接收请求，查库，读⽂件等，拼接好返回的HTTP响应 5. 浏览器收到⾸屏html，开始渲染 6. 解析html为dom 7. 解析css 为css-tree 8. dom+ css ⽣成render-tree 绘图 9. 加载script的js⽂件 10. 执⾏js // DNS 优化 &lt;link rel=\"dns-prefetch\" href=\"dns的地址\"/&gt; // IP TCP HTTP的关系 1、IP负责找到资源 2、TCP负责数据的完整性和有序性，三次握手四次挥手 3、http应用层，负责应用层数据 // 优化 1. ⻓连接 2. 减少⽂件体积 1. js打包压缩 2. 图⽚压缩 3. gzip 3. 减少⽂件请求次数 1. 雪碧图 2. js，css打包 3. 缓存控制 4. 懒加载 4. 减少⽤户和服务器的距离 1. cdn 5. 本地存储 6. http优化 将验证放在header中 // 通过⽹络获取内容既速度缓慢⼜开销巨⼤。较⼤的响应需要在客户端与服务器之间进⾏多次往返通信， // 这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费⽤。因此，缓存并重复利⽤之前获取 // 的资源的能⼒成为性能优化的⼀个关键⽅⾯。 7、浏览器缓存 1. Http Cache 2. Service Worker Cache 独立于主线程之外的js,实现离线缓存和网络代理 window.navigator.serviceWorker.register('/xxx.js').then( function () { console.log('注册成功') }).catch(err =&gt; { console.error(\"注册失败\") }) 3. Memory Cache 4. Push Cache // header中设置 强缓存 expires: Wed, 11 Mar 2019 16:12:18 GMT cache-control: max-age=31536000 // 1.1 精准 优先级⾼ // 协商缓存 304 not Modified 1、第一种方式 If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT 2、第二种方式 ETag: W/\"2aaa-129892f459\" // 类似文件的指纹 If-None-Match: W/\"2aaa-129892f459\" 文件打包 webpack图片优化// performance performance.getEntriesByType('navigation') // lighthouse npm install -g lighthouse lighthouse https://www.kaikeba.com/ --view // 以上两个用于性能监控 图⽚通常是最占⽤流量的，PC端加载的平均图⽚⼤⼩时600K. 不同的场景，使⽤不同的⽂件⾥类型 1. jpg 1. 有损压缩 2. 体积⼩ 不⽀持透明 3. ⽤于背景图，轮播图 2. png 1. ⽆损压缩，质量⾼，⽀持透明 2. ⾊彩线条更丰富，⼩图，⽐如logo，商品icon 3. svg 1. ⽂本，体积⼩ ⽮量图 2. 渲染成本，学习成本 gzip accept-encoding:gzip 开启gzipHTTP 压缩就是以缩⼩体积为⽬的，对 HTTP 内容进⾏重新编码的过程 Gzip 压缩背后的原理，是在⼀个⽂本⽂件中找出⼀些重复出现的字符串、临时替换它们，从⽽使整个⽂ 件变⼩。根据这个原理，⽂件中代码的重复率越⾼，那么压缩的效率就越⾼，使⽤ Gzip 的收益也就越 ⼤。 基本上来说，Gzip都是服务器⼲的活，⽐如nginx 服务器端渲染 React的Nextjs Vue的NuxtjsReact的长列表加载 React-virtualizedimport { List } from \"react-virtualized\"; &lt;div className=\"list\"&gt; &lt;List width={rowWidth} height={listHeight} rowHeight={rowHeight} rowRenderer={this.renderRow.bind(this)} rowCount={this.list.length} /&gt; &lt;/div&gt; renderRow({ index, key, style }) { return ( &lt;div key={key} style={style} className=\"row\"&gt; &lt;div className=\"image\"&gt; &lt;img src={this.list[index].image} alt=\"\" /&gt; &lt;/div&gt; &lt;div className=\"content\"&gt; &lt;div&gt;{this.list[index].name}&lt;/div&gt; &lt;div&gt;{this.list[index].text}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } 白屏应对⻣架，⾃动化⽅案，page-skeleton-webpack-plugin, 以及antd的skeleton组件 移动端点击事件300s的延迟和点击穿透// 移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动。这些行为，尤其是双击缩放，主要是为桌面网站在移动端的浏览体验设计的。而在用户对页面进行操作的时候，移动端浏览器会优先判断用户是否要触发默认的行为。 1、方案一：禁用缩放 &lt;meta name=\"viewport\" content=\"user-scalable=no\"&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1\"&gt; 2、方案二：更改默认的视口宽度 &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; 方案一、二 Chrome支持 3、CSS touch-action: none IE支持 主要解决方案: // 使用FastClick库 // FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。 // 点击穿透 说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？ 使用touchstart去代替click事件有两个不好的地方。 第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果； 第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。 // 什么是点击穿透？ 假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。 这是因为在移动端浏览器，事件执行的顺序是touchstart &gt; touchend &gt; click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://promisefine.github.io/tags/Web/"}],"author":"Doney"},{"title":"Http的缓存机制","slug":"cache","date":"2019-10-20T00:20:18.000Z","updated":"2021-07-16T03:23:36.443Z","comments":true,"path":"posts/41476be7.html","link":"","permalink":"https://promisefine.github.io/posts/41476be7.html","excerpt":"","text":"Http的缓存机制function updatetime() { this.timer = this.timer || setInterval(() =&gt; this.time = Date.now(), 5000) return this.time } const http = require('http') http.createServer((req, res) =&gt; { const { url } = req if ('/' === url) { res.end(` &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;/head&gt; 更新时间 | ${updatetime()} &lt;script src=\"/main.js\"&gt;&lt;/script&gt; &lt;/html&gt; `) } else if (url === '/main.js') { const content = `document.write('&lt;br&gt;main | ${updatetime()}')` // 强缓存 expire // res.setHeader('Expires',new Date(Date.now()+10*1000).toGMTString()) // res.setHeader('Cache-Control','max-age=10') res.setHeader('Cache-Control', 'no-cache') // 设置过期时间 // res.setHeader('last-modified',new Date().toGMTString()) // if(new Date(req.headers['if-modified-since']).getTime() + 8*60*3600*1000 + 3 &gt; Date.now()){ // console.log(\"协商缓存命中\"); // res.statusCode = 304 // res.end('') // return // } // 另一种协商缓存 hash const crypto = require('crypto') const hash = crypto.createHash('sha1').update(content).digest('hex') console.log(hash, \"----\"); console.log(req.headers, \"+++++++\"); res.setHeader('Etag', hash) if (req.headers['if-none-match'] === hash) { console.log(\"协商缓存命中\"); res.statusCode = 304 res.end('') return } res.statusCode = 200 res.end(content) } else if (url === '/favicon.ico') { res.end('') } }) .listen(3000, () =&gt; { console.log('服务器运行在3000端口'); }) 异步读取文件const fs = require('fs') const {promisify} = require('util') const readFile = promisify(fs.readFile) process.nextTick(async () =&gt; { const data = await readFile('./index.html') // console.log(data.toString()); const buf = Buffer.alloc(10) console.log(data); }) 流 node基于流const fs = require('fs') const rs = fs.createReadStream('./index.html') const ws = fs.createWriteStream('./home.html') rs.pipe(ws) 制定auto-vue-routernpm i commander download-git-repo ora handlebars figlet clear chalk open -s // bin/yl.js #!/usr/bin/env node const program = require('commander') program.version(require('../package').version) program .command('init &lt;name&gt;') .description('init project') // .action(name =&gt; { // console.log('init ' + name) // }) .action(require('../lib/init')) program .command('refresh') .description('refresh routers...') .action(require('../lib/refresh')) program.parse(process.argv) // lib/init.js // 将异步变成同步 const { promisify } = require('util') // 输出一些特殊的文字 为异步方法 const figlet = promisify(require('figlet')) const clear = require('clear') // 改变命令行风格 --- 颜色等 const chalk = require('chalk') const log = content =&gt; console.log(chalk.green(content)) // clone克隆 const {clone} = require('./download') // 安装依赖 const spawn = async (...args) =&gt; { // 开启子进程 const { spawn } = require('child_process'); return new Promise(resolve =&gt; { const proc = spawn(...args) // 输出流 子进程导入到主进程 proc.stdout.pipe(process.stdout) // 错误流 proc.stderr.pipe(process.stderr) proc.on('close', () =&gt; { resolve() }) }) } // 打开浏览器 const open = require(\"open\") module.exports = async name =&gt; { console.log(name, \"|| name\"); // 打印欢迎画⾯ clear() const data = await figlet('yl Welcome') log(data); log('🚀创建项⽬:' + name) // 克隆项目 await clone('github:su37josephxia/vue-template', name) // 安装依赖 log('安装依赖'); // cnpm install ./test await spawn('cnpm', ['install'], { cwd: `./${name}` }) log(chalk.green(` To get Start: =========================== cd ${name} npm run serve =========================== `)) // 打开浏览器 open(`http://localhost:8080`); await spawn('npm', ['run', 'serve'], { cwd: `./${name}` }) } // lib/download.js const { promisify } = require('util') module.exports.clone = async function (repo, desc) { const download = promisify(require('download-git-repo')) const ora = require('ora') const process = ora(`下载.....${repo}`) process.start() await download(repo, desc) process.succeed() } // lib/refresh.js const fs = require('fs') const handlebars = require('handlebars') const chalk = require('chalk') module.exports = async () =&gt; { // 获取⻚⾯列表 const list = fs.readdirSync('./src/views') .filter(v =&gt; v !== 'Home.vue') .map(v =&gt; ({ name: v.replace('.vue', '').toLowerCase(), file: v })) // ⽣成路由定义 compile({ list }, './src/router.js', './template/router.js.hbs') // ⽣成菜单 compile({ list }, './src/App.vue', './template/App.vue.hbs') /** * 编译模板⽂件 * @param meta 数据定义 * @param filePath ⽬标⽂件路径 * @param templatePath 模板⽂件路径 */ function compile(meta, filePath, templatePath) { if (fs.existsSync(templatePath)) { const content = fs.readFileSync(templatePath).toString(); const result = handlebars.compile(content)(meta); fs.writeFileSync(filePath, result); } console.log(chalk.green(`🚀${filePath} 创建成功`)) } } AOP：Aspect Oriented Programming 面向切面编程日志记录，性能统计，安全控制，事务处理，异常处理等等。Koaconst Koa = require('koa') const app = new Koa() app.use(require('koa-static')(__dirname + '../public/')) const router = require('koa-router')() router.get('/string', async (ctx, next) =&gt; { ctx.body = 'koa2 string' }) router.get('/json', async (ctx, next) =&gt; { ctx.body = { title: 'koa2 json' } }) app.use(router.routes()) app.use(async (ctx, next) =&gt; { const start = new Date().getTime() console.log(`start: ${ctx.url}`); await next() const end = new Date().getTime() console.log(`${ctx.url} | 耗时: ${end - start}ms`); }) app.use((ctx) =&gt; { ctx.body = 'Hello Koa' }) app.listen(3000) 组合函数 compose函数Koa中间件机制就是函数式 组合概念 Compose的概念，将⼀组需要顺序执⾏的函数复合为⼀个函数，外层函数的参数实际是内层函数的返回值。const add = (x, y) =&gt; x + y const square = z =&gt; z * z const fn = (x, y) =&gt; square(add(x, y)) console.log(fn(1, 2)) const compose = (fn1, fn2) =&gt; (...args) =&gt; fn2(fn1(...args)) const fn = compose(add,square) const compose = (...[first, ...other]) =&gt; (...args) =&gt; { let ret = first(...args) other.forEach(fn =&gt; { ret = fn(ret) }) return ret } const fn = compose(add, square) console.log(fn(1, 2)) function compose(middlewares) { return function () { return dispatch(0); // 执⾏第0个 function dispatch(i) { let fn = middlewares[i]; if (!fn) { return Promise.resolve(); } return Promise.resolve( fn(function next() { // promise完成后，再执⾏下⼀个 return dispatch(i + 1); }) ); } }; } async function fn1(next) { console.log(\"fn1\"); await next(); console.log(\"end fn1\"); } async function fn2(next) { console.log(\"fn2\"); await delay(); await next(); console.log(\"end fn2\"); } function fn4(next) { console.log(\"fn4\"); next() } async function fn3(next) { console.log(\"fn3\"); await delay(); await next(); console.log(\"end fn3\"); } function delay() { return new Promise((reslove) =&gt; { setTimeout(() =&gt; { reslove(); }, 2000); }); } const middlewares = [fn1, fn2, fn4, fn3]; const finalFn = compose(middlewares); finalFn();","categories":[],"tags":[{"name":"Http","slug":"Http","permalink":"https://promisefine.github.io/tags/Http/"}],"author":"Doney"},{"title":"设计模式","slug":"Design","date":"2019-10-08T06:22:10.000Z","updated":"2021-07-16T06:01:35.676Z","comments":true,"path":"posts/364ea8cc.html","link":"","permalink":"https://promisefine.github.io/posts/364ea8cc.html","excerpt":"","text":"设计模式（Design Pattern）是⼀套被反复使⽤、多数⼈知晓的、经过分类的、代码设计经验的总结。发布订阅模式class Event { constructor() { this.callbacks = {} } $off(name) { this.callbacks[name] = null } $emit(name, args) { let cbs = this.callbacks[name] if (cbs) { cbs.forEach(c =&gt; { c.call(this, args) }) } } $on(name, fn) { (this.callbacks[name] || (this.callbacks[name] = [])).push(fn) } } let event = new Event() event.$on('event1', function (arg) { console.log('事件1', arg) }) event.$on('event1', function (arg) { console.log('⼜⼀个时间1', arg) }) event.$on('event2', function (arg) { console.log('事件2', arg) }) event.$emit('event1', { name: '2005A' }) event.$emit('event2', { name: '2006A' }) event.$off('event1') event.$emit('event1', { name: '2007A' }) 单例模式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;单例模式&lt;/title&gt; &lt;style&gt; .model { border: 1px solid black; position: fixed; width: 300px; height: 300px; top: 20%; left: 50%; margin-left: -150px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;弹窗，⽆论点击多少次，弹窗只应该被创建⼀次&lt;/h1&gt; &lt;div id=\"loginBtn\"&gt;点我&lt;/div&gt; &lt;script&gt; var getSingle = function (fn) { var result; return function () { return result || (result = fn.apply(this, arguments)); } }; var createLoginLayer = function () { var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.className = 'model' div.style.display = 'none'; document.body.appendChild(div); return div; }; // 单例模式 可以去掉一下这一行代码试试页面点击情况 var createSingleLoginLayer = getSingle(createLoginLayer); document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 策略模式⼀个基于策略模式的程序⾄少由两部分组成。 // 第⼀个部分是⼀组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。 // 第⼆个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某⼀个策略类。 // 例子： var calc = function (pm, salary) { if (pm === 'S') { return salary * 4; } if (pm === 'A') { return salary * 3; } if (pm === 'B') { return salary * 2; } }; calculateBonus('B', 20000); // 输出:40000 calculateBonus('S', 6000); // 输出:24000 // 使用策略模式 var strategies = { \"S\": function (salary) { return salary * 4; }, \"A\": function (salary) { return salary * 3; }, \"B\": function (salary) { return salary * 2; } }; var calculateBonus = function (level, salary) { return strategies[level](salary); }; console.log(calculateBonus('S', 20000)); // 输出:80000 console.log(calculateBonus('A', 10000)); // 输出:30000 // 表单校验 var registerForm = document.getElementById('registerForm'); registerForm.onsubmit = function () { if (registerForm.userName.value === '') { alert('⽤户名不能为空'); return false; } if (registerForm.password.value.length &lt; 6) { alert('密码⻓度不能少于 6 位'); return false; } if (!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) { alert('⼿机号码格式不正确'); return false; } } // 使用策略模式 var strategies = { isNonEmpty: function (value, errorMsg) { if (value === '') { return errorMsg; } }, minLength: function (value, length, errorMsg) { if (value.length &lt; length) { return errorMsg; } }, isMobile: function (value, errorMsg) { // ⼿机号码格式 if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) { return errorMsg; } } }; var Validator = function () { this.cache = []; // 保存校验规则 }; Validator.prototype.add = function (){ var ary = rule.split(':'); this.cache.push(function () { // var strategy = ary.shift(); ary.unshift(dom.value); ary.push(errorMsg); return strategies[strategy].apply(dom, ary); }); }; Validator.prototype.start = function () { for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) { var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) { // 如果有确切的返回值，说明校验没有通过 return msg; } } }; var validataFunc = function () { var validator = new Validator(); // 创建⼀个 validator 对象 /***************添加⼀些校验规则****************/ validator.add(registerForm.userName, 'isNonEmpty', '⽤户名不能为空'); validator.add(registerForm.password, 'minLength:6', '密码⻓度不能少于 6位'); validator.add(registerForm.phoneNumber, 'isMobile', '⼿机号码格式不正确'); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果 } var registerForm = document.getElementById('registerForm'); registerForm.onsubmit = function () { var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if (errorMsg) { alert(errorMsg); return false; // 阻⽌表单提交 } }; 代理模式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .model { border: 1px solid black; position: fixed; width: 300px; height: 300px; top: 20%; left: 50%; margin-left: -150px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"checkbox\" id=\"1\"&gt; &lt;input type=\"checkbox\" id=\"2\"&gt; &lt;input type=\"checkbox\" id=\"3\"&gt; &lt;script&gt; var synchronousFile = function (id) { console.log('开始同步⽂件，id 为: ' + id); }; var proxySynchronousFile = (function () { var cache = [], // 保存⼀段时间内需要同步的 ID timer; // 定时器 return function (id) { cache.push(id); if (timer) { // 保证不会覆盖已经启动的定时器 return; } timer = setTimeout(function () { synchronousFile(cache.join(',')); clearTimeout(timer); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 }, 2000); } // 2 秒后向本体发送需要同步的 ID 集合 })(); var checkbox = document.getElementsByTagName('input'); for (var i = 0, c; c = checkbox[i++];) { c.onclick = function () { if (this.checked === true) { proxySynchronousFile(this.id); } } }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 工厂模式装饰器模式享元模式(优化模式，常用在封装弹框组件)export default { install(Vue) { // 在使⽤插件Vue.use(Message)时实例化⼀个Dialog组件对象 const Dialog = new Vue({ data() { return { icon: '', fontStyle: '', backgroundStyle: '', text: '' } } ... }) // 扩展Vue的`prototype` Vue.prototype.$Message = { success(text) { // 改变Dialog的data.xx的值触发Dialog的更新 Dialog.icon = successIcon Dialog.fontStyle = successFontStyle Dialog.backgroundStyle = successBackgroundStyle Dialog.text = text // 获取Dialog的最新DOM添加到body标签中 document.body.appendChild(Dialog.$el) }, warning(text) { // 同上 ... document.body.appendChild(Dialog.$el) }, error(text) { // 同上 ... document.body.appendChild(Dialog.$el) } } } }","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"Promise并发","slug":"Concurrent","date":"2019-09-24T00:38:23.000Z","updated":"2021-07-16T03:23:42.984Z","comments":true,"path":"posts/9123c35c.html","link":"","permalink":"https://promisefine.github.io/posts/9123c35c.html","excerpt":"","text":"代码演示var urls = [ \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting1.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting2.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting3.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting4.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/AboutMe-painting5.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn6.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn7.png\", \"https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/bpmn8.png\", ]; function loadImg(url) { return new Promise((resolve, reject) =&gt; { const img = new Image(); img.onload = function() { console.log(\"一张图片加载完成\"); resolve(img); }; img.onerror = function() { reject(new Error('地址加载失败:' + url)); }; img.src = url; }); }; function limitImageLoad(urls, handler, limit) { let sequence = [].concat(urls); // 复制urls // 这一步是为了初始化 promises 这个\"容器\" let promises = sequence.splice(0, limit).map((url, index) =&gt; { return handler(url).then(() =&gt; { // 返回下标是为了知道数组中是哪一项最先完成 return index; }); }); // 注意这里要将整个变量过程返回，这样得到的就是一个Promise，可以在外面链式调用 return sequence .reduce((pCollect, url) =&gt; { return pCollect .then(() =&gt; { return Promise.race(promises); // 返回已经完成的下标 }) .then((fastestIndex) =&gt; { // 获取到已经完成的下标 // 将\"容器\"内已经完成的那一项替换 promises[fastestIndex] = handler(url).then(() =&gt; { return fastestIndex; // 要继续将这个下标返回，以便下一次变量 }); }) .catch((err) =&gt; { console.error(err); }); }, Promise.resolve()) // 初始化传入 .then(() =&gt; { // 最后三个用.all来调用 return Promise.all(promises); }); } // 代码调用 limitImageLoad(urls, loadImg, 3) .then((res) =&gt; { console.log(\"图片全部加载完毕\"); console.log(res); }) .catch((err) =&gt; { console.error(err); });","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"Promise","slug":"Promise","date":"2019-09-23T02:00:43.000Z","updated":"2021-07-16T03:24:03.339Z","comments":true,"path":"posts/23a0e66.html","link":"","permalink":"https://promisefine.github.io/posts/23a0e66.html","excerpt":"","text":"代码演示class myPromise { // 准备状态 static PENDING = 'pending' // 完成状态 static FULFILLED = 'fulfilled' // 失败状态 static REJECTED = 'rejected' constructor(executor) { this.status = myPromise.PENDING this.value = null this.callbacks = [] try { executor(this.resolve.bind(this), this.reject.bind(this)) } catch (error) { this.reject(error) } } // 类方法 // 成功 resolve(value) { // console.log(this) // 改变promise的状态 解决状态 if (this.status = myPromise.PENDING) { this.status = myPromise.FULFILLED this.value = value } // 变为异步任务 setTimeout(() =&gt; { this.callbacks.map(callback =&gt; { callback.onFulfilled(value) }) }); } // 失败 reject(reason) { if (this.status = myPromise.PENDING) { this.status = myPromise.REJECTED this.value = reason } // 变为异步任务 setTimeout(() =&gt; { this.callbacks.map(callback =&gt; { callback.onRejected(reason) }) }); } // then then(onFulfilled, onRejected) { if (typeof onFulfilled != 'function') { onFulfilled = () =&gt; { } } if (typeof onRejected != 'function') { onRejected = () =&gt; { } } // 当状态为准备状态 if (this.status == myPromise.PENDING) { this.callbacks.push({ onFulfilled: value =&gt; { try { onFulfilled(value) } catch (error) { onRejected(error) } }, onRejected: value =&gt; { try { onRejected(value) } catch (error) { onRejected(error) } } }) } // 当状态为完成的时候执行 if (this.status == myPromise.FULFILLED) { // 放到队列。轮询执行 setTimeout(() =&gt; { // 处理错误 try { onFulfilled(this.value) } catch (error) { onRejected(error) } }) } // 当状态为失败的时候执行 if (this.status == myPromise.REJECTED) { // 放到队列。轮询执行 setTimeout(() =&gt; { // 处理错误 try { onRejected(this.value) } catch (error) { onRejected(error) } }) } } }","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"debounce","slug":"debounce","date":"2019-09-21T02:24:47.000Z","updated":"2021-07-16T03:23:47.839Z","comments":true,"path":"posts/dbf34790.html","link":"","permalink":"https://promisefine.github.io/posts/dbf34790.html","excerpt":"","text":"代码演示const button = document.querySelector('button') function patMoney() { console.log('已剁') } // 创建一个防抖函数 function debounce(func, delay) { // 防止在定义监听函数的时候就直接执行了函数 所以我们用到高阶函数 let timer // 闭包 因为作用域链的关系 所有独立的执行函数都能访问到这个timer变量 return function () { let context = this let args = arguments clearTimeout(timer) // 设置setTimeout timer = setTimeout(function () { func.apply(context, args) }, delay) } } button.addEventListener('click', debounce(patMoney, 3000))","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"throttle","slug":"throttle","date":"2019-09-20T03:45:23.000Z","updated":"2021-07-16T03:24:07.656Z","comments":true,"path":"posts/ebdc48ec.html","link":"","permalink":"https://promisefine.github.io/posts/ebdc48ec.html","excerpt":"","text":"代码演示function coloring() { let r = Math.floor(Math.random() * 255) let g = Math.floor(Math.random() * 255) let b = Math.floor(Math.random() * 255) document.body.style.background = `rgb(${r},${g},${b})` } function throttle(func, delay) { let pre = 0 return function () { let now = new Date() let context = this let args = arguments if (now - pre &gt; delay) { func.apply(context, args) pre = now } } } window.addEventListener('resize', throttle(coloring, 2000))","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"热血发言","slug":"introduce","date":"2019-09-18T02:13:01.000Z","updated":"2021-07-16T06:01:55.646Z","comments":true,"path":"posts/3714eea.html","link":"","permalink":"https://promisefine.github.io/posts/3714eea.html","excerpt":"","text":"热爱互联网热爱前端热爱敲代码一包烟一杯茶一个Bug改一天我秃了但我变强了！","categories":[],"tags":[{"name":"introduce","slug":"introduce","permalink":"https://promisefine.github.io/tags/introduce/"}],"author":"Doney"}],"categories":[],"tags":[{"name":"Vite","slug":"Vite","permalink":"https://promisefine.github.io/tags/Vite/"},{"name":"Koa","slug":"Koa","permalink":"https://promisefine.github.io/tags/Koa/"},{"name":"Vue","slug":"Vue","permalink":"https://promisefine.github.io/tags/Vue/"},{"name":"Webpack","slug":"Webpack","permalink":"https://promisefine.github.io/tags/Webpack/"},{"name":"Linux","slug":"Linux","permalink":"https://promisefine.github.io/tags/Linux/"},{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"},{"name":"Web","slug":"Web","permalink":"https://promisefine.github.io/tags/Web/"},{"name":"Http","slug":"Http","permalink":"https://promisefine.github.io/tags/Http/"},{"name":"introduce","slug":"introduce","permalink":"https://promisefine.github.io/tags/introduce/"}]}