{"meta":{"title":"Doney","subtitle":"卷野の博客","description":"专科 | 计算机科学与技术 | 网络安全","author":"Doney","url":"https://promisefine.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.354Z","comments":true,"path":"404.html","permalink":"https://promisefine.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-07-12T00:45:59.563Z","updated":"2021-07-12T00:45:59.563Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://promisefine.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"","date":"2021-07-12T00:45:59.560Z","updated":"2021-07-12T00:45:59.560Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://promisefine.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.389Z","comments":true,"path":"List/index.html","permalink":"https://promisefine.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.560Z","comments":true,"path":"categories/index.html","permalink":"https://promisefine.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.559Z","comments":true,"path":"archives/index.html","permalink":"https://promisefine.github.io/archives/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.564Z","comments":true,"path":"resource/index.html","permalink":"https://promisefine.github.io/resource/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-14T06:09:43.269Z","comments":true,"path":"contact/index.html","permalink":"https://promisefine.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-07-12T00:45:59.561Z","comments":true,"path":"census/index.html","permalink":"https://promisefine.github.io/census/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.566Z","comments":true,"path":"tags/index.html","permalink":"https://promisefine.github.io/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.391Z","comments":true,"path":"List/music/index.html","permalink":"https://promisefine.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/index.html","permalink":"https://promisefine.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-12T00:45:59.558Z","comments":true,"path":"about/index.html","permalink":"https://promisefine.github.io/about/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-12T00:45:59.390Z","comments":true,"path":"List/movies/index.html","permalink":"https://promisefine.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-12T00:45:59.392Z","comments":true,"path":"List/tools/index.html","permalink":"https://promisefine.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://promisefine.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-07-12T00:45:59.362Z","updated":"2021-07-12T00:45:59.362Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://promisefine.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-07-12T00:45:59.372Z","updated":"2021-07-12T00:45:59.372Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-07-12T00:45:59.384Z","updated":"2021-07-12T00:45:59.384Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-07-12T00:45:59.379Z","updated":"2021-07-12T00:45:59.379Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://promisefine.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-07-12T00:45:59.386Z","updated":"2021-07-12T00:45:59.386Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-07-12T00:45:59.382Z","updated":"2021-07-12T00:45:59.382Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://promisefine.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-07-12T00:45:59.380Z","updated":"2021-07-12T00:45:59.380Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://promisefine.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-07-12T00:45:59.387Z","updated":"2021-07-12T00:45:59.387Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://promisefine.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"算法","slug":"algorithm","date":"2019-11-29T02:01:45.000Z","updated":"2021-07-15T11:48:33.858Z","comments":true,"path":"posts/9505ccb9.html","link":"","permalink":"https://promisefine.github.io/posts/9505ccb9.html","excerpt":"","text":"复杂度// 大O算法就是算法执⾏所需要的执⾏次数，和数据量的关系(时间复杂度),占⽤额外空间和数据量的关系(空间复杂度) O(1) : 常数复杂度 (和数据量⽆关) O(logn) :对数复杂度 (⼆分) O(n) : 线性时间复杂度 （数组遍历⼀次） O(n*logn) : 线性对数 （遍历+⼆分） O(n^2) : 平⽅ 两层遍历 O(2^n) : 指数 递归 O(n!) : 阶乘 冒泡排序function bubleSort(arr) { var len = arr.length for (let outer = len; outer &gt;= 2; outer--) { for (let inner = 0; inner &lt;= outer - 1; inner++) { if (arr[inner] &gt; arr[inner + 1]) { [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]] } } } return arr } console.log(bubleSort([4, 3, 6, 1, 9, 6, 2])) 插入排序function insertSort(arr) { for (let i = 1; i &lt; arr.length; i++) { //外循环从1开始，默认arr[0]是有序段 for (let j = i; j &gt; 0; j--) { //j = i,将arr[j]依次插⼊有序段中 if (arr[j] &lt; arr[j - 1]) { [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]; } else { break; } } } return arr; } console.log(insertSort([11, 4, 3, 6, 1, 9, 7, 2, 0])) 快速排序function quickSort(arr) { if (arr.length &lt;= 1) { return arr; //递归出⼝ } var left = [], right = [], current = arr.splice(0, 1); //注意splice后，数组⻓度少了⼀个 for (let i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; current) { left.push(arr[i]) //放在左边 } else { right.push(arr[i]) //放在右边 } } return quickSort(left).concat(current, quickSort(right)); //递归 } 数组扁平化Array.prototype.flat = function () { var arr = []; this.forEach((item, idx) =&gt; { if (Array.isArray(item)) { arr = arr.concat(item.flat()); //递归去处理数组元素 } else { arr.push(item) //⾮数组直接push进去 } }) return arr; //递归出⼝ } arr = [1, 2, 3, [4, 5, [6, 7, [8, 9]]], [10, 11] ] console.log(arr.flat()) 查找算法// 循环的二分查找 function binarySearch(arr, target) { var low = 0, high = arr.length - 1, mid; while (low &lt;= high) { mid = Math.floor((low + high) / 2); if (target === arr[mid]) { return `找到了${target},在第${mid + 1}个` } if (target &gt; arr[mid]) { low = mid + 1; } else if (target &lt; arr[mid]) { high = mid - 1; } } return -1 } console.log(binarySearch([1, 2, 3, 4, 5, 7, 9, 11, 14, 16, 17, 22, 33, 55, 65], 4)) // 递归的二分查找 function binarySearch1(arr, target, low = 0, high = arr.length - 1) { const n = Math.floor((low + high) / 2); const cur = arr[n]; if (cur === target) { return `找到了${target},在第${n+1}个`; } else if (cur &gt; target) { return binarySearch1(arr, target, low, n - 1); } else if (cur &lt; target) { return binarySearch1(arr, target, n + 1, high); } return -1; } 数据结构栈class Stack { constructor() { this.items = [] } push(item) { this.items.push(item) } pop() { return this.items.pop() } size() { return this.items.length } clear() { this.items = [] } } 索引: O(n) 搜索: O(n) 插⼊: O(1) 移除: O(1) // 经典案例： 括号匹配，html标签匹配，进制转换 function isBalance(symbol) { const stack = new Stack() const left = '{(' const right = '})' let popValue let tag = true const match = function (popValue, current) { if (left.indexOf(popValue) !== right.indexOf(current)) { tag = false } } for (let i = 0; i &lt; symbol.length; i++) { if (left.includes(symbol[i])) { stack.push(symbol[i]) } else if (right.includes(symbol[i])) { popValue = stack.pop() match(popValue, symbol[i]) } } return tag } console.log(isBalance('{{(({}))}}')) console.log(isBalance('{{(({})}}')) 链表 class Node { constructor(element) { this.element = element this.next = null } } class LinkedList { constructor() { this.head = null this.current this.length = 0 } append(element) { const node = new Node(element) if (this.head === null) { // 插⼊第⼀个链表 this.head = node } else { this.current = this.head while (this.current.next) { // 找到最后⼀个节点 this.current = this.current.next } this.current.next = node } this.length++ } // 移除指定位置元素 removeAt(position) { if (position &gt; -1 &amp;&amp; position &lt; this.length) { let previous let index = 0 if (position === 0) { // 如果是第⼀个链表的话, 特殊对待 this.head = this.head.next } else { 开课吧web全栈架构师 this.current = this.head while (index &lt; position) { // 循环找到当前要删除元素的位置 previous = this.current this.current = this.current.next index++ } previous.next = this.current.next } this.length-- } } // 在指定位置加⼊元素 insert(position, element) { const node = new Node(element) let index = 0 let current, previous if (position &gt; -1 &amp;&amp; position &lt; this.length + 1) { if (position === 0) { // 在链表最前插⼊元素 current = this.head this.head = node this.head.next = current } else { current = this.head while (index &lt; position) { // 同 removeAt 逻辑, 找到⽬标位置 previous = current current = current.next index++ } previous.next = node // 在⽬标位置插⼊相应元素 node.next = current } this.length++ } } // 链表中是否含有某个元素, 如果有的话返回相应位置, ⽆的话返回 -1 indexOf(element) { let index = 0 this.current = this.head while (index &lt; this.length) { if (this.current.element === element) { return index } this.current = this.current.next index++ } return -1 } // 移除某元素 remove(element) { const position = this.indexOf(element) this.removeAt(position) } // 获取⼤⼩ size() { return this.length } // 获取最开头的链表 getHead() { return this.head } // 是否为空 isEmpty() { return this.length === 0 } // 打印链表元素 log() { this.current = this.head let str = this.current.element while (this.current.next) { this.current = this.current.next str = str + ' ' + this.current.element } console.log(str) return str } } // 测试⽤例 var linkedList = new LinkedList() linkedList.append(5) linkedList.append(10) linkedList.append(15) linkedList.append(20) linkedList.log() // '5 10 15 20' linkedList.removeAt(1) linkedList.log() // '5 15 20' linkedList.insert(1, 10) linkedList.log() 集合 Set和Mapnew Set() new WeekSet() new Map() new WeekMap() class Set { constructor() { this.items = {} } has(value) { return this.items.hasOwnProperty(value) } add(value) { if (!this.has(value)) { this.items[value] = value return true } return false } remove(value) { if (this.has(value)) { delete this.items[value] return true } return false } get size() { return Object.keys(this.items).length } get values() { return Object.keys(this.items) } } const set = new Set() set.add(1) console.log(set.values) // [\"1\"] console.log(set.has(1)) // true console.log(set.size) // 1 set.add(2) console.log(set.values) // [\"1\", \"2\"] console.log(set.has(2)) // true console.log(set.size) // 2 set.remove(1) console.log(set.values) // [\"2\"] set.remove(2) console.log(set.values) // [] 哈希表 名称 散列函数 散列值 散列表 John 74+111+104+110 399 [399] [john@qq.com] class HashTable { constructor() { this.items = {} } put(key, value) { const hash = this.keyToHash(key) this.items[hash] = value } get(key) { return this.items[this.keyToHash(key)] } remove(key) { delete(this.items[this.keyToHash(key)]) } keyToHash(key) { let hash = 0 for (let i = 0; i &lt; key.length; i++) { hash += key.charCodeAt(i) } hash = hash % 37 // 为了避免 hash 的值过⼤ return hash } } let ht = new HashTable() ht.put('name', 'xxx') ht.put('age', '6') console.log(ht.get('name')) ht.remove('name') console.log(ht.get('name')) 算法技巧动态规划// 例如斐波那契 // 递归 function fib(n) { if (n == 1 || n == 2) return 1 return fib(n - 1) + fib(n - 2) } // 动归 解决子问题重复 function fib(n) { let memo = [] return helper(memo, n) } function helper(memo, n) { if (n == 1 || n == 2) { // 前两个 return 1 } // 如果有缓存，直接返回 if (memo[n]) return memo[n]; // 没缓存 memo[n] = helper(memo, n - 1) + helper(memo, n - 2) return memo[n] } // 动归解决 function fib(n) { let dp = [] dp[1] = dp[2] = 1 for (let i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n] } // 假如有1,5,10,20,50,100人民币 4 [1, 1, 1, 1] // 需 4 个 1 5 [5] // 需 1 个 5 36 [20, 10, 5, 1] // 需 20、10、5、1各⼀个 class Change { constructor(changeType) { this.changeType = changeType this.cache = {} } makeChange(amount) { let min = [] if (!amount) { return [] } if (this.cache[amount]) { // 读缓存 return this.cache[amount] } for (let i = 0; i &lt; this.changeType.length; i++) { const leftAmount = amount - this.changeType[i] let newMin if (leftAmount &gt;= 0) { newMin = this.makeChange(leftAmount) // 这⼀句是动态规划的提现 } if (leftAmount &gt;= 0 &amp;&amp; (newMin.length &lt; min.length - 1 || !min.length)) { // 如果存在更⼩的找零硬币数, 则执⾏后⾯语句 min = [this.changeType[i]].concat(newMin) } } return this.cache[amount] = min } } const change = new Change([1, 5, 10, 20, 50, 100]) console.log(change.makeChange(2)) console.log(change.makeChange(5)) console.log(change.makeChange(13)) console.log(change.makeChange(35)) console.log(change.makeChange(135)) 贪心算法 // 贪⼼ 先找最大面值，超了再找其他的 class Change { constructor(changeType) { this.changeType = changeType.sort((r1, r2) =&gt; r2 - r1) } makeChange(amount) { const arr = [] for (let i = 0; i &lt; this.changeType.length; i++) { while (amount - this.changeType[i] &gt;= 0) { arr.push(this.changeType[i]) amount = amount - this.changeType[i] } } return arr } } const change = new Change([1, 5, 10, 20, 50, 100]) console.log(change.makeChange(36)) console.log(change.makeChange(136)) console.log('-'.repeat(100)) // 有时贪心算法不一定准确，求的最大近似解 const change1 = new Change([1, 3, 4]) console.log(change1.makeChange(6)) // 其实[3, 3]最好","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"设计模式","slug":"Design","date":"2019-10-08T06:22:10.000Z","updated":"2021-07-15T11:48:48.707Z","comments":true,"path":"posts/364ea8cc.html","link":"","permalink":"https://promisefine.github.io/posts/364ea8cc.html","excerpt":"","text":"设计模式（Design Pattern）是⼀套被反复使⽤、多数⼈知晓的、经过分类的、代码设计经验的总结。发布订阅模式class Event { constructor() { this.callbacks = {} } $off(name) { this.callbacks[name] = null } $emit(name, args) { let cbs = this.callbacks[name] if (cbs) { cbs.forEach(c =&gt; { c.call(this, args) }) } } $on(name, fn) { (this.callbacks[name] || (this.callbacks[name] = [])).push(fn) } } let event = new Event() event.$on('event1', function (arg) { console.log('事件1', arg) }) event.$on('event1', function (arg) { console.log('⼜⼀个时间1', arg) }) event.$on('event2', function (arg) { console.log('事件2', arg) }) event.$emit('event1', { name: '2005A' }) event.$emit('event2', { name: '2006A' }) event.$off('event1') event.$emit('event1', { name: '2007A' }) 单例模式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;单例模式&lt;/title&gt; &lt;style&gt; .model { border: 1px solid black; position: fixed; width: 300px; height: 300px; top: 20%; left: 50%; margin-left: -150px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;弹窗，⽆论点击多少次，弹窗只应该被创建⼀次&lt;/h1&gt; &lt;div id=\"loginBtn\"&gt;点我&lt;/div&gt; &lt;script&gt; var getSingle = function (fn) { var result; return function () { return result || (result = fn.apply(this, arguments)); } }; var createLoginLayer = function () { var div = document.createElement('div'); div.innerHTML = '我是登录浮窗'; div.className = 'model' div.style.display = 'none'; document.body.appendChild(div); return div; }; // 单例模式 可以去掉一下这一行代码试试页面点击情况 var createSingleLoginLayer = getSingle(createLoginLayer); document.getElementById('loginBtn').onclick = function () { var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block'; }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 策略模式⼀个基于策略模式的程序⾄少由两部分组成。 // 第⼀个部分是⼀组策略类（可变），策略类封装了具体的算法，并负责具体的计算过程。 // 第⼆个部分是环境类Context（不变），Context接受客户的请求，随后将请求委托给某⼀个策略类。 // 例子： var calc = function (pm, salary) { if (pm === 'S') { return salary * 4; } if (pm === 'A') { return salary * 3; } if (pm === 'B') { return salary * 2; } }; calculateBonus('B', 20000); // 输出:40000 calculateBonus('S', 6000); // 输出:24000 // 使用策略模式 var strategies = { \"S\": function (salary) { return salary * 4; }, \"A\": function (salary) { return salary * 3; }, \"B\": function (salary) { return salary * 2; } }; var calculateBonus = function (level, salary) { return strategies[level](salary); }; console.log(calculateBonus('S', 20000)); // 输出:80000 console.log(calculateBonus('A', 10000)); // 输出:30000 // 表单校验 var registerForm = document.getElementById('registerForm'); registerForm.onsubmit = function () { if (registerForm.userName.value === '') { alert('⽤户名不能为空'); return false; } if (registerForm.password.value.length &lt; 6) { alert('密码⻓度不能少于 6 位'); return false; } if (!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) { alert('⼿机号码格式不正确'); return false; } } // 使用策略模式 var strategies = { isNonEmpty: function (value, errorMsg) { if (value === '') { return errorMsg; } }, minLength: function (value, length, errorMsg) { if (value.length &lt; length) { return errorMsg; } }, isMobile: function (value, errorMsg) { // ⼿机号码格式 if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) { return errorMsg; } } }; var Validator = function () { this.cache = []; // 保存校验规则 }; Validator.prototype.add = function (){ var ary = rule.split(':'); this.cache.push(function () { // var strategy = ary.shift(); ary.unshift(dom.value); ary.push(errorMsg); return strategies[strategy].apply(dom, ary); }); }; Validator.prototype.start = function () { for (var i = 0, validatorFunc; validatorFunc = this.cache[i++];) { var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息 if (msg) { // 如果有确切的返回值，说明校验没有通过 return msg; } } }; var validataFunc = function () { var validator = new Validator(); // 创建⼀个 validator 对象 /***************添加⼀些校验规则****************/ validator.add(registerForm.userName, 'isNonEmpty', '⽤户名不能为空'); validator.add(registerForm.password, 'minLength:6', '密码⻓度不能少于 6位'); validator.add(registerForm.phoneNumber, 'isMobile', '⼿机号码格式不正确'); var errorMsg = validator.start(); // 获得校验结果 return errorMsg; // 返回校验结果 } var registerForm = document.getElementById('registerForm'); registerForm.onsubmit = function () { var errorMsg = validataFunc(); // 如果 errorMsg 有确切的返回值，说明未通过校验 if (errorMsg) { alert(errorMsg); return false; // 阻⽌表单提交 } }; 代理模式&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .model { border: 1px solid black; position: fixed; width: 300px; height: 300px; top: 20%; left: 50%; margin-left: -150px; text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"checkbox\" id=\"1\"&gt; &lt;input type=\"checkbox\" id=\"2\"&gt; &lt;input type=\"checkbox\" id=\"3\"&gt; &lt;script&gt; var synchronousFile = function (id) { console.log('开始同步⽂件，id 为: ' + id); }; var proxySynchronousFile = (function () { var cache = [], // 保存⼀段时间内需要同步的 ID timer; // 定时器 return function (id) { cache.push(id); if (timer) { // 保证不会覆盖已经启动的定时器 return; } timer = setTimeout(function () { synchronousFile(cache.join(',')); clearTimeout(timer); // 清空定时器 timer = null; cache.length = 0; // 清空 ID 集合 }, 2000); } // 2 秒后向本体发送需要同步的 ID 集合 })(); var checkbox = document.getElementsByTagName('input'); for (var i = 0, c; c = checkbox[i++];) { c.onclick = function () { if (this.checked === true) { proxySynchronousFile(this.id); } } }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 工厂模式装饰器模式享元模式(优化模式，常用在封装弹框组件)export default { install(Vue) { // 在使⽤插件Vue.use(Message)时实例化⼀个Dialog组件对象 const Dialog = new Vue({ data() { return { icon: '', fontStyle: '', backgroundStyle: '', text: '' } } ... }) // 扩展Vue的`prototype` Vue.prototype.$Message = { success(text) { // 改变Dialog的data.xx的值触发Dialog的更新 Dialog.icon = successIcon Dialog.fontStyle = successFontStyle Dialog.backgroundStyle = successBackgroundStyle Dialog.text = text // 获取Dialog的最新DOM添加到body标签中 document.body.appendChild(Dialog.$el) }, warning(text) { // 同上 ... document.body.appendChild(Dialog.$el) }, error(text) { // 同上 ... document.body.appendChild(Dialog.$el) } } } }","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}]},{"title":"Promise","slug":"Promise","date":"2019-09-23T02:00:43.000Z","updated":"2021-07-15T11:49:00.170Z","comments":true,"path":"posts/23a0e66.html","link":"","permalink":"https://promisefine.github.io/posts/23a0e66.html","excerpt":"","text":"代码演示class myPromise { // 准备状态 static PENDING = 'pending' // 完成状态 static FULFILLED = 'fulfilled' // 失败状态 static REJECTED = 'rejected' constructor(executor) { this.status = myPromise.PENDING this.value = null this.callbacks = [] try { executor(this.resolve.bind(this), this.reject.bind(this)) } catch (error) { this.reject(error) } } // 类方法 // 成功 resolve(value) { // console.log(this) // 改变promise的状态 解决状态 if (this.status = myPromise.PENDING) { this.status = myPromise.FULFILLED this.value = value } // 变为异步任务 setTimeout(() =&gt; { this.callbacks.map(callback =&gt; { callback.onFulfilled(value) }) }); } // 失败 reject(reason) { if (this.status = myPromise.PENDING) { this.status = myPromise.REJECTED this.value = reason } // 变为异步任务 setTimeout(() =&gt; { this.callbacks.map(callback =&gt; { callback.onRejected(reason) }) }); } // then then(onFulfilled, onRejected) { if (typeof onFulfilled != 'function') { onFulfilled = () =&gt; { } } if (typeof onRejected != 'function') { onRejected = () =&gt; { } } // 当状态为准备状态 if (this.status == myPromise.PENDING) { this.callbacks.push({ onFulfilled: value =&gt; { try { onFulfilled(value) } catch (error) { onRejected(error) } }, onRejected: value =&gt; { try { onRejected(value) } catch (error) { onRejected(error) } } }) } // 当状态为完成的时候执行 if (this.status == myPromise.FULFILLED) { // 放到队列。轮询执行 setTimeout(() =&gt; { // 处理错误 try { onFulfilled(this.value) } catch (error) { onRejected(error) } }) } // 当状态为失败的时候执行 if (this.status == myPromise.REJECTED) { // 放到队列。轮询执行 setTimeout(() =&gt; { // 处理错误 try { onRejected(this.value) } catch (error) { onRejected(error) } }) } } }","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"debounce","slug":"debounce","date":"2019-09-21T02:24:47.000Z","updated":"2021-07-15T11:48:20.247Z","comments":true,"path":"posts/dbf34790.html","link":"","permalink":"https://promisefine.github.io/posts/dbf34790.html","excerpt":"","text":"代码演示const button = document.querySelector('button') function patMoney() { console.log('已剁') } // 创建一个防抖函数 function debounce(func, delay) { // 防止在定义监听函数的时候就直接执行了函数 所以我们用到高阶函数 let timer // 闭包 因为作用域链的关系 所有独立的执行函数都能访问到这个timer变量 return function () { let context = this let args = arguments clearTimeout(timer) // 设置setTimeout timer = setTimeout(function () { func.apply(context, args) }, delay) } } button.addEventListener('click', debounce(patMoney, 3000))","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"throttle","slug":"throttle","date":"2019-09-20T03:45:23.000Z","updated":"2021-07-15T11:48:12.739Z","comments":true,"path":"posts/ebdc48ec.html","link":"","permalink":"https://promisefine.github.io/posts/ebdc48ec.html","excerpt":"","text":"代码演示function coloring() { let r = Math.floor(Math.random() * 255) let g = Math.floor(Math.random() * 255) let b = Math.floor(Math.random() * 255) document.body.style.background = `rgb(${r},${g},${b})` } function throttle(func, delay) { let pre = 0 return function () { let now = new Date() let context = this let args = arguments if (now - pre &gt; delay) { func.apply(context, args) pre = now } } } window.addEventListener('resize', throttle(coloring, 2000))","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"}],"author":"Doney"},{"title":"热血发言","slug":"introduce","date":"2019-09-18T02:13:01.000Z","updated":"2021-07-15T11:46:05.400Z","comments":true,"path":"posts/3714eea.html","link":"","permalink":"https://promisefine.github.io/posts/3714eea.html","excerpt":"","text":"热爱互联网热爱前端热爱敲代码一包烟一杯茶一个Bug改一天我秃了但我变强了！","categories":[],"tags":[{"name":"introduce","slug":"introduce","permalink":"https://promisefine.github.io/tags/introduce/"}]}],"categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://promisefine.github.io/tags/Javascript/"},{"name":"introduce","slug":"introduce","permalink":"https://promisefine.github.io/tags/introduce/"}]}